{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n/**\n * Window Sections are used to group nearby cells.\n * This enables us to more quickly determine which cells to display in a given region of the Window.\n * \n */\n\nimport Section from './Section';\nvar SECTION_SIZE = 100;\n/**\n * Contains 0 to many Sections.\n * Grows (and adds Sections) dynamically as cells are registered.\n * Automatically adds cells to the appropriate Section(s).\n */\n\nvar SectionManager = /*#__PURE__*/function () {\n  function SectionManager() {\n    var sectionSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SECTION_SIZE;\n\n    _classCallCheck(this, SectionManager);\n\n    this._sectionSize = sectionSize;\n    this._cellMetadata = [];\n    this._sections = {};\n  }\n  /**\n   * Gets all cell indices contained in the specified region.\n   * A region may encompass 1 or more Sections.\n   */\n\n\n  _createClass(SectionManager, [{\n    key: \"getCellIndices\",\n    value: function getCellIndices(_ref) {\n      var height = _ref.height,\n          width = _ref.width,\n          x = _ref.x,\n          y = _ref.y;\n      var indices = {};\n      this.getSections({\n        height: height,\n        width: width,\n        x: x,\n        y: y\n      }).forEach(function (section) {\n        return section.getCellIndices().forEach(function (index) {\n          indices[index] = index;\n        });\n      }); // Object keys are strings; this function returns numbers\n\n      return Object.keys(indices).map(function (index) {\n        return indices[index];\n      });\n    }\n    /** Get size and position information for the cell specified. */\n\n  }, {\n    key: \"getCellMetadata\",\n    value: function getCellMetadata(_ref2) {\n      var index = _ref2.index;\n      return this._cellMetadata[index];\n    }\n    /** Get all Sections overlapping the specified region. */\n\n  }, {\n    key: \"getSections\",\n    value: function getSections(_ref3) {\n      var height = _ref3.height,\n          width = _ref3.width,\n          x = _ref3.x,\n          y = _ref3.y;\n      var sectionXStart = Math.floor(x / this._sectionSize);\n      var sectionXStop = Math.floor((x + width - 1) / this._sectionSize);\n      var sectionYStart = Math.floor(y / this._sectionSize);\n      var sectionYStop = Math.floor((y + height - 1) / this._sectionSize);\n      var sections = [];\n\n      for (var sectionX = sectionXStart; sectionX <= sectionXStop; sectionX++) {\n        for (var sectionY = sectionYStart; sectionY <= sectionYStop; sectionY++) {\n          var key = \"\".concat(sectionX, \".\").concat(sectionY);\n\n          if (!this._sections[key]) {\n            this._sections[key] = new Section({\n              height: this._sectionSize,\n              width: this._sectionSize,\n              x: sectionX * this._sectionSize,\n              y: sectionY * this._sectionSize\n            });\n          }\n\n          sections.push(this._sections[key]);\n        }\n      }\n\n      return sections;\n    }\n    /** Total number of Sections based on the currently registered cells. */\n\n  }, {\n    key: \"getTotalSectionCount\",\n    value: function getTotalSectionCount() {\n      return Object.keys(this._sections).length;\n    }\n    /** Intended for debugger/test purposes only */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var _this = this;\n\n      return Object.keys(this._sections).map(function (index) {\n        return _this._sections[index].toString();\n      });\n    }\n    /** Adds a cell to the appropriate Sections and registers it metadata for later retrievable. */\n\n  }, {\n    key: \"registerCell\",\n    value: function registerCell(_ref4) {\n      var cellMetadatum = _ref4.cellMetadatum,\n          index = _ref4.index;\n      this._cellMetadata[index] = cellMetadatum;\n      this.getSections(cellMetadatum).forEach(function (section) {\n        return section.addCellIndex({\n          index: index\n        });\n      });\n    }\n  }]);\n\n  return SectionManager;\n}();\n\nexport { SectionManager as default };\nimport { bpfrpt_proptype_Index } from \"./types\";\nimport { bpfrpt_proptype_SizeAndPositionInfo } from \"./types\";","map":{"version":3,"names":["_classCallCheck","_createClass","Section","SECTION_SIZE","SectionManager","sectionSize","arguments","length","undefined","_sectionSize","_cellMetadata","_sections","key","value","getCellIndices","_ref","height","width","x","y","indices","getSections","forEach","section","index","Object","keys","map","getCellMetadata","_ref2","_ref3","sectionXStart","Math","floor","sectionXStop","sectionYStart","sectionYStop","sections","sectionX","sectionY","concat","push","getTotalSectionCount","toString","_this","registerCell","_ref4","cellMetadatum","addCellIndex","default","bpfrpt_proptype_Index","bpfrpt_proptype_SizeAndPositionInfo"],"sources":["/Users/stoneye/react_project/circle-app-react-hook/node_modules/react-virtualized/dist/es/Collection/SectionManager.js"],"sourcesContent":["import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\n/**\n * Window Sections are used to group nearby cells.\n * This enables us to more quickly determine which cells to display in a given region of the Window.\n * \n */\nimport Section from './Section';\nvar SECTION_SIZE = 100;\n\n/**\n * Contains 0 to many Sections.\n * Grows (and adds Sections) dynamically as cells are registered.\n * Automatically adds cells to the appropriate Section(s).\n */\nvar SectionManager =\n/*#__PURE__*/\nfunction () {\n  function SectionManager() {\n    var sectionSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SECTION_SIZE;\n\n    _classCallCheck(this, SectionManager);\n\n    this._sectionSize = sectionSize;\n    this._cellMetadata = [];\n    this._sections = {};\n  }\n  /**\n   * Gets all cell indices contained in the specified region.\n   * A region may encompass 1 or more Sections.\n   */\n\n\n  _createClass(SectionManager, [{\n    key: \"getCellIndices\",\n    value: function getCellIndices(_ref) {\n      var height = _ref.height,\n          width = _ref.width,\n          x = _ref.x,\n          y = _ref.y;\n      var indices = {};\n      this.getSections({\n        height: height,\n        width: width,\n        x: x,\n        y: y\n      }).forEach(function (section) {\n        return section.getCellIndices().forEach(function (index) {\n          indices[index] = index;\n        });\n      }); // Object keys are strings; this function returns numbers\n\n      return Object.keys(indices).map(function (index) {\n        return indices[index];\n      });\n    }\n    /** Get size and position information for the cell specified. */\n\n  }, {\n    key: \"getCellMetadata\",\n    value: function getCellMetadata(_ref2) {\n      var index = _ref2.index;\n      return this._cellMetadata[index];\n    }\n    /** Get all Sections overlapping the specified region. */\n\n  }, {\n    key: \"getSections\",\n    value: function getSections(_ref3) {\n      var height = _ref3.height,\n          width = _ref3.width,\n          x = _ref3.x,\n          y = _ref3.y;\n      var sectionXStart = Math.floor(x / this._sectionSize);\n      var sectionXStop = Math.floor((x + width - 1) / this._sectionSize);\n      var sectionYStart = Math.floor(y / this._sectionSize);\n      var sectionYStop = Math.floor((y + height - 1) / this._sectionSize);\n      var sections = [];\n\n      for (var sectionX = sectionXStart; sectionX <= sectionXStop; sectionX++) {\n        for (var sectionY = sectionYStart; sectionY <= sectionYStop; sectionY++) {\n          var key = \"\".concat(sectionX, \".\").concat(sectionY);\n\n          if (!this._sections[key]) {\n            this._sections[key] = new Section({\n              height: this._sectionSize,\n              width: this._sectionSize,\n              x: sectionX * this._sectionSize,\n              y: sectionY * this._sectionSize\n            });\n          }\n\n          sections.push(this._sections[key]);\n        }\n      }\n\n      return sections;\n    }\n    /** Total number of Sections based on the currently registered cells. */\n\n  }, {\n    key: \"getTotalSectionCount\",\n    value: function getTotalSectionCount() {\n      return Object.keys(this._sections).length;\n    }\n    /** Intended for debugger/test purposes only */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var _this = this;\n\n      return Object.keys(this._sections).map(function (index) {\n        return _this._sections[index].toString();\n      });\n    }\n    /** Adds a cell to the appropriate Sections and registers it metadata for later retrievable. */\n\n  }, {\n    key: \"registerCell\",\n    value: function registerCell(_ref4) {\n      var cellMetadatum = _ref4.cellMetadatum,\n          index = _ref4.index;\n      this._cellMetadata[index] = cellMetadatum;\n      this.getSections(cellMetadatum).forEach(function (section) {\n        return section.addCellIndex({\n          index: index\n        });\n      });\n    }\n  }]);\n\n  return SectionManager;\n}();\n\nexport { SectionManager as default };\nimport { bpfrpt_proptype_Index } from \"./types\";\nimport { bpfrpt_proptype_SizeAndPositionInfo } from \"./types\";"],"mappings":"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"},"metadata":{},"sourceType":"module"}