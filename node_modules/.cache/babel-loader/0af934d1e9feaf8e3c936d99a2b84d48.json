{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nvar _class, _temp;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport * as React from 'react';\nimport clsx from 'clsx';\nimport calculateSizeAndPositionDataAndUpdateScrollOffset from './utils/calculateSizeAndPositionDataAndUpdateScrollOffset';\nimport ScalingCellSizeAndPositionManager from './utils/ScalingCellSizeAndPositionManager';\nimport createCallbackMemoizer from '../utils/createCallbackMemoizer';\nimport defaultOverscanIndicesGetter, { SCROLL_DIRECTION_BACKWARD, SCROLL_DIRECTION_FORWARD } from './defaultOverscanIndicesGetter';\nimport updateScrollIndexHelper from './utils/updateScrollIndexHelper';\nimport defaultCellRangeRenderer from './defaultCellRangeRenderer';\nimport scrollbarSize from 'dom-helpers/scrollbarSize';\nimport { polyfill } from 'react-lifecycles-compat';\nimport { requestAnimationTimeout, cancelAnimationTimeout } from '../utils/requestAnimationTimeout';\n/**\n * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.\n * This improves performance and makes scrolling smoother.\n */\n\nexport var DEFAULT_SCROLLING_RESET_TIME_INTERVAL = 150;\n/**\n * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.\n * This prevents Grid from interrupting mouse-wheel animations (see issue #2).\n */\n\nvar SCROLL_POSITION_CHANGE_REASONS = {\n  OBSERVED: 'observed',\n  REQUESTED: 'requested'\n};\n\nvar renderNull = function renderNull() {\n  return null;\n};\n/**\n * Renders tabular data with virtualization along the vertical and horizontal axes.\n * Row heights and column widths must be known ahead of time and specified as properties.\n */\n\n\nvar Grid = (_temp = _class = /*#__PURE__*/function (_React$PureComponent) {\n  _inherits(Grid, _React$PureComponent); // Invokes onSectionRendered callback only when start/stop row or column indices change\n\n\n  function Grid(props) {\n    var _this;\n\n    _classCallCheck(this, Grid);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Grid).call(this, props));\n\n    _defineProperty(_assertThisInitialized(_this), \"_onGridRenderedMemoizer\", createCallbackMemoizer());\n\n    _defineProperty(_assertThisInitialized(_this), \"_onScrollMemoizer\", createCallbackMemoizer(false));\n\n    _defineProperty(_assertThisInitialized(_this), \"_deferredInvalidateColumnIndex\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"_deferredInvalidateRowIndex\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"_recomputeScrollLeftFlag\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"_recomputeScrollTopFlag\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"_horizontalScrollBarSize\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_verticalScrollBarSize\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_scrollbarPresenceChanged\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"_scrollingContainer\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_childrenToDisplay\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_columnStartIndex\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_columnStopIndex\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_rowStartIndex\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_rowStopIndex\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_renderedColumnStartIndex\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_renderedColumnStopIndex\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_renderedRowStartIndex\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_renderedRowStopIndex\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_initialScrollTop\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_initialScrollLeft\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_disablePointerEventsTimeoutId\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_styleCache\", {});\n\n    _defineProperty(_assertThisInitialized(_this), \"_cellCache\", {});\n\n    _defineProperty(_assertThisInitialized(_this), \"_debounceScrollEndedCallback\", function () {\n      _this._disablePointerEventsTimeoutId = null; // isScrolling is used to determine if we reset styleCache\n\n      _this.setState({\n        isScrolling: false,\n        needToResetStyleCache: false\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_invokeOnGridRenderedHelper\", function () {\n      var onSectionRendered = _this.props.onSectionRendered;\n\n      _this._onGridRenderedMemoizer({\n        callback: onSectionRendered,\n        indices: {\n          columnOverscanStartIndex: _this._columnStartIndex,\n          columnOverscanStopIndex: _this._columnStopIndex,\n          columnStartIndex: _this._renderedColumnStartIndex,\n          columnStopIndex: _this._renderedColumnStopIndex,\n          rowOverscanStartIndex: _this._rowStartIndex,\n          rowOverscanStopIndex: _this._rowStopIndex,\n          rowStartIndex: _this._renderedRowStartIndex,\n          rowStopIndex: _this._renderedRowStopIndex\n        }\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_setScrollingContainerRef\", function (ref) {\n      _this._scrollingContainer = ref;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_onScroll\", function (event) {\n      // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.\n      // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.\n      // See issue #404 for more information.\n      if (event.target === _this._scrollingContainer) {\n        _this.handleScrollEvent(event.target);\n      }\n    });\n\n    var columnSizeAndPositionManager = new ScalingCellSizeAndPositionManager({\n      cellCount: props.columnCount,\n      cellSizeGetter: function cellSizeGetter(params) {\n        return Grid._wrapSizeGetter(props.columnWidth)(params);\n      },\n      estimatedCellSize: Grid._getEstimatedColumnSize(props)\n    });\n    var rowSizeAndPositionManager = new ScalingCellSizeAndPositionManager({\n      cellCount: props.rowCount,\n      cellSizeGetter: function cellSizeGetter(params) {\n        return Grid._wrapSizeGetter(props.rowHeight)(params);\n      },\n      estimatedCellSize: Grid._getEstimatedRowSize(props)\n    });\n    _this.state = {\n      instanceProps: {\n        columnSizeAndPositionManager: columnSizeAndPositionManager,\n        rowSizeAndPositionManager: rowSizeAndPositionManager,\n        prevColumnWidth: props.columnWidth,\n        prevRowHeight: props.rowHeight,\n        prevColumnCount: props.columnCount,\n        prevRowCount: props.rowCount,\n        prevIsScrolling: props.isScrolling === true,\n        prevScrollToColumn: props.scrollToColumn,\n        prevScrollToRow: props.scrollToRow,\n        scrollbarSize: 0,\n        scrollbarSizeMeasured: false\n      },\n      isScrolling: false,\n      scrollDirectionHorizontal: SCROLL_DIRECTION_FORWARD,\n      scrollDirectionVertical: SCROLL_DIRECTION_FORWARD,\n      scrollLeft: 0,\n      scrollTop: 0,\n      scrollPositionChangeReason: null,\n      needToResetStyleCache: false\n    };\n\n    if (props.scrollToRow > 0) {\n      _this._initialScrollTop = _this._getCalculatedScrollTop(props, _this.state);\n    }\n\n    if (props.scrollToColumn > 0) {\n      _this._initialScrollLeft = _this._getCalculatedScrollLeft(props, _this.state);\n    }\n\n    return _this;\n  }\n  /**\n   * Gets offsets for a given cell and alignment.\n   */\n\n\n  _createClass(Grid, [{\n    key: \"getOffsetForCell\",\n    value: function getOffsetForCell() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$alignment = _ref.alignment,\n          alignment = _ref$alignment === void 0 ? this.props.scrollToAlignment : _ref$alignment,\n          _ref$columnIndex = _ref.columnIndex,\n          columnIndex = _ref$columnIndex === void 0 ? this.props.scrollToColumn : _ref$columnIndex,\n          _ref$rowIndex = _ref.rowIndex,\n          rowIndex = _ref$rowIndex === void 0 ? this.props.scrollToRow : _ref$rowIndex;\n\n      var offsetProps = _objectSpread({}, this.props, {\n        scrollToAlignment: alignment,\n        scrollToColumn: columnIndex,\n        scrollToRow: rowIndex\n      });\n\n      return {\n        scrollLeft: this._getCalculatedScrollLeft(offsetProps),\n        scrollTop: this._getCalculatedScrollTop(offsetProps)\n      };\n    }\n    /**\n     * Gets estimated total rows' height.\n     */\n\n  }, {\n    key: \"getTotalRowsHeight\",\n    value: function getTotalRowsHeight() {\n      return this.state.instanceProps.rowSizeAndPositionManager.getTotalSize();\n    }\n    /**\n     * Gets estimated total columns' width.\n     */\n\n  }, {\n    key: \"getTotalColumnsWidth\",\n    value: function getTotalColumnsWidth() {\n      return this.state.instanceProps.columnSizeAndPositionManager.getTotalSize();\n    }\n    /**\n     * This method handles a scroll event originating from an external scroll control.\n     * It's an advanced method and should probably not be used unless you're implementing a custom scroll-bar solution.\n     */\n\n  }, {\n    key: \"handleScrollEvent\",\n    value: function handleScrollEvent(_ref2) {\n      var _ref2$scrollLeft = _ref2.scrollLeft,\n          scrollLeftParam = _ref2$scrollLeft === void 0 ? 0 : _ref2$scrollLeft,\n          _ref2$scrollTop = _ref2.scrollTop,\n          scrollTopParam = _ref2$scrollTop === void 0 ? 0 : _ref2$scrollTop; // On iOS, we can arrive at negative offsets by swiping past the start.\n      // To prevent flicker here, we make playing in the negative offset zone cause nothing to happen.\n\n      if (scrollTopParam < 0) {\n        return;\n      } // Prevent pointer events from interrupting a smooth scroll\n\n\n      this._debounceScrollEnded();\n\n      var _this$props = this.props,\n          autoHeight = _this$props.autoHeight,\n          autoWidth = _this$props.autoWidth,\n          height = _this$props.height,\n          width = _this$props.width;\n      var instanceProps = this.state.instanceProps; // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,\n      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.\n      // This causes a series of rapid renders that is slow for long lists.\n      // We can avoid that by doing some simple bounds checking to ensure that scroll offsets never exceed their bounds.\n\n      var scrollbarSize = instanceProps.scrollbarSize;\n      var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n      var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n      var scrollLeft = Math.min(Math.max(0, totalColumnsWidth - width + scrollbarSize), scrollLeftParam);\n      var scrollTop = Math.min(Math.max(0, totalRowsHeight - height + scrollbarSize), scrollTopParam); // Certain devices (like Apple touchpad) rapid-fire duplicate events.\n      // Don't force a re-render if this is the case.\n      // The mouse may move faster then the animation frame does.\n      // Use requestAnimationFrame to avoid over-updating.\n\n      if (this.state.scrollLeft !== scrollLeft || this.state.scrollTop !== scrollTop) {\n        // Track scrolling direction so we can more efficiently overscan rows to reduce empty space around the edges while scrolling.\n        // Don't change direction for an axis unless scroll offset has changed.\n        var scrollDirectionHorizontal = scrollLeft !== this.state.scrollLeft ? scrollLeft > this.state.scrollLeft ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionHorizontal;\n        var scrollDirectionVertical = scrollTop !== this.state.scrollTop ? scrollTop > this.state.scrollTop ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionVertical;\n        var newState = {\n          isScrolling: true,\n          scrollDirectionHorizontal: scrollDirectionHorizontal,\n          scrollDirectionVertical: scrollDirectionVertical,\n          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.OBSERVED\n        };\n\n        if (!autoHeight) {\n          newState.scrollTop = scrollTop;\n        }\n\n        if (!autoWidth) {\n          newState.scrollLeft = scrollLeft;\n        }\n\n        newState.needToResetStyleCache = false;\n        this.setState(newState);\n      }\n\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop,\n        totalColumnsWidth: totalColumnsWidth,\n        totalRowsHeight: totalRowsHeight\n      });\n    }\n    /**\n     * Invalidate Grid size and recompute visible cells.\n     * This is a deferred wrapper for recomputeGridSize().\n     * It sets a flag to be evaluated on cDM/cDU to avoid unnecessary renders.\n     * This method is intended for advanced use-cases like CellMeasurer.\n     */\n    // @TODO (bvaughn) Add automated test coverage for this.\n\n  }, {\n    key: \"invalidateCellSizeAfterRender\",\n    value: function invalidateCellSizeAfterRender(_ref3) {\n      var columnIndex = _ref3.columnIndex,\n          rowIndex = _ref3.rowIndex;\n      this._deferredInvalidateColumnIndex = typeof this._deferredInvalidateColumnIndex === 'number' ? Math.min(this._deferredInvalidateColumnIndex, columnIndex) : columnIndex;\n      this._deferredInvalidateRowIndex = typeof this._deferredInvalidateRowIndex === 'number' ? Math.min(this._deferredInvalidateRowIndex, rowIndex) : rowIndex;\n    }\n    /**\n     * Pre-measure all columns and rows in a Grid.\n     * Typically cells are only measured as needed and estimated sizes are used for cells that have not yet been measured.\n     * This method ensures that the next call to getTotalSize() returns an exact size (as opposed to just an estimated one).\n     */\n\n  }, {\n    key: \"measureAllCells\",\n    value: function measureAllCells() {\n      var _this$props2 = this.props,\n          columnCount = _this$props2.columnCount,\n          rowCount = _this$props2.rowCount;\n      var instanceProps = this.state.instanceProps;\n      instanceProps.columnSizeAndPositionManager.getSizeAndPositionOfCell(columnCount - 1);\n      instanceProps.rowSizeAndPositionManager.getSizeAndPositionOfCell(rowCount - 1);\n    }\n    /**\n     * Forced recompute of row heights and column widths.\n     * This function should be called if dynamic column or row sizes have changed but nothing else has.\n     * Since Grid only receives :columnCount and :rowCount it has no way of detecting when the underlying data changes.\n     */\n\n  }, {\n    key: \"recomputeGridSize\",\n    value: function recomputeGridSize() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref4$columnIndex = _ref4.columnIndex,\n          columnIndex = _ref4$columnIndex === void 0 ? 0 : _ref4$columnIndex,\n          _ref4$rowIndex = _ref4.rowIndex,\n          rowIndex = _ref4$rowIndex === void 0 ? 0 : _ref4$rowIndex;\n\n      var _this$props3 = this.props,\n          scrollToColumn = _this$props3.scrollToColumn,\n          scrollToRow = _this$props3.scrollToRow;\n      var instanceProps = this.state.instanceProps;\n      instanceProps.columnSizeAndPositionManager.resetCell(columnIndex);\n      instanceProps.rowSizeAndPositionManager.resetCell(rowIndex); // Cell sizes may be determined by a function property.\n      // In this case the cDU handler can't know if they changed.\n      // Store this flag to let the next cDU pass know it needs to recompute the scroll offset.\n\n      this._recomputeScrollLeftFlag = scrollToColumn >= 0 && (this.state.scrollDirectionHorizontal === SCROLL_DIRECTION_FORWARD ? columnIndex <= scrollToColumn : columnIndex >= scrollToColumn);\n      this._recomputeScrollTopFlag = scrollToRow >= 0 && (this.state.scrollDirectionVertical === SCROLL_DIRECTION_FORWARD ? rowIndex <= scrollToRow : rowIndex >= scrollToRow); // Clear cell cache in case we are scrolling;\n      // Invalid row heights likely mean invalid cached content as well.\n\n      this._styleCache = {};\n      this._cellCache = {};\n      this.forceUpdate();\n    }\n    /**\n     * Ensure column and row are visible.\n     */\n\n  }, {\n    key: \"scrollToCell\",\n    value: function scrollToCell(_ref5) {\n      var columnIndex = _ref5.columnIndex,\n          rowIndex = _ref5.rowIndex;\n      var columnCount = this.props.columnCount;\n      var props = this.props; // Don't adjust scroll offset for single-column grids (eg List, Table).\n      // This can cause a funky scroll offset because of the vertical scrollbar width.\n\n      if (columnCount > 1 && columnIndex !== undefined) {\n        this._updateScrollLeftForScrollToColumn(_objectSpread({}, props, {\n          scrollToColumn: columnIndex\n        }));\n      }\n\n      if (rowIndex !== undefined) {\n        this._updateScrollTopForScrollToRow(_objectSpread({}, props, {\n          scrollToRow: rowIndex\n        }));\n      }\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props4 = this.props,\n          getScrollbarSize = _this$props4.getScrollbarSize,\n          height = _this$props4.height,\n          scrollLeft = _this$props4.scrollLeft,\n          scrollToColumn = _this$props4.scrollToColumn,\n          scrollTop = _this$props4.scrollTop,\n          scrollToRow = _this$props4.scrollToRow,\n          width = _this$props4.width;\n      var instanceProps = this.state.instanceProps; // Reset initial offsets to be ignored in browser\n\n      this._initialScrollTop = 0;\n      this._initialScrollLeft = 0; // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.\n      // We must do this at the start of the method as we may calculate and update scroll position below.\n\n      this._handleInvalidatedGridSize(); // If this component was first rendered server-side, scrollbar size will be undefined.\n      // In that event we need to remeasure.\n\n\n      if (!instanceProps.scrollbarSizeMeasured) {\n        this.setState(function (prevState) {\n          var stateUpdate = _objectSpread({}, prevState, {\n            needToResetStyleCache: false\n          });\n\n          stateUpdate.instanceProps.scrollbarSize = getScrollbarSize();\n          stateUpdate.instanceProps.scrollbarSizeMeasured = true;\n          return stateUpdate;\n        });\n      }\n\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0 || typeof scrollTop === 'number' && scrollTop >= 0) {\n        var stateUpdate = Grid._getScrollToPositionStateUpdate({\n          prevState: this.state,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        });\n\n        if (stateUpdate) {\n          stateUpdate.needToResetStyleCache = false;\n          this.setState(stateUpdate);\n        }\n      } // refs don't work in `react-test-renderer`\n\n\n      if (this._scrollingContainer) {\n        // setting the ref's scrollLeft and scrollTop.\n        // Somehow in MultiGrid the main grid doesn't trigger a update on mount.\n        if (this._scrollingContainer.scrollLeft !== this.state.scrollLeft) {\n          this._scrollingContainer.scrollLeft = this.state.scrollLeft;\n        }\n\n        if (this._scrollingContainer.scrollTop !== this.state.scrollTop) {\n          this._scrollingContainer.scrollTop = this.state.scrollTop;\n        }\n      } // Don't update scroll offset if the size is 0; we don't render any cells in this case.\n      // Setting a state may cause us to later thing we've updated the offce when we haven't.\n\n\n      var sizeIsBiggerThanZero = height > 0 && width > 0;\n\n      if (scrollToColumn >= 0 && sizeIsBiggerThanZero) {\n        this._updateScrollLeftForScrollToColumn();\n      }\n\n      if (scrollToRow >= 0 && sizeIsBiggerThanZero) {\n        this._updateScrollTopForScrollToRow();\n      } // Update onRowsRendered callback\n\n\n      this._invokeOnGridRenderedHelper(); // Initialize onScroll callback\n\n\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft || 0,\n        scrollTop: scrollTop || 0,\n        totalColumnsWidth: instanceProps.columnSizeAndPositionManager.getTotalSize(),\n        totalRowsHeight: instanceProps.rowSizeAndPositionManager.getTotalSize()\n      });\n\n      this._maybeCallOnScrollbarPresenceChange();\n    }\n    /**\n     * @private\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) New scroll-to-cell props have been set\n     */\n\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this2 = this;\n\n      var _this$props5 = this.props,\n          autoHeight = _this$props5.autoHeight,\n          autoWidth = _this$props5.autoWidth,\n          columnCount = _this$props5.columnCount,\n          height = _this$props5.height,\n          rowCount = _this$props5.rowCount,\n          scrollToAlignment = _this$props5.scrollToAlignment,\n          scrollToColumn = _this$props5.scrollToColumn,\n          scrollToRow = _this$props5.scrollToRow,\n          width = _this$props5.width;\n      var _this$state = this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollPositionChangeReason = _this$state.scrollPositionChangeReason,\n          scrollTop = _this$state.scrollTop,\n          instanceProps = _this$state.instanceProps; // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.\n      // We must do this at the start of the method as we may calculate and update scroll position below.\n\n      this._handleInvalidatedGridSize(); // Handle edge case where column or row count has only just increased over 0.\n      // In this case we may have to restore a previously-specified scroll offset.\n      // For more info see bvaughn/react-virtualized/issues/218\n\n\n      var columnOrRowCountJustIncreasedFromZero = columnCount > 0 && prevProps.columnCount === 0 || rowCount > 0 && prevProps.rowCount === 0; // Make sure requested changes to :scrollLeft or :scrollTop get applied.\n      // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,\n      // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).\n      // So we only set these when we require an adjustment of the scroll position.\n      // See issue #2 for more information.\n\n      if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {\n        // @TRICKY :autoHeight and :autoWidth properties instructs Grid to leave :scrollTop and :scrollLeft management to an external HOC (eg WindowScroller).\n        // In this case we should avoid checking scrollingContainer.scrollTop and scrollingContainer.scrollLeft since it forces layout/flow.\n        if (!autoWidth && scrollLeft >= 0 && (scrollLeft !== this._scrollingContainer.scrollLeft || columnOrRowCountJustIncreasedFromZero)) {\n          this._scrollingContainer.scrollLeft = scrollLeft;\n        }\n\n        if (!autoHeight && scrollTop >= 0 && (scrollTop !== this._scrollingContainer.scrollTop || columnOrRowCountJustIncreasedFromZero)) {\n          this._scrollingContainer.scrollTop = scrollTop;\n        }\n      } // Special case where the previous size was 0:\n      // In this case we don't show any windowed cells at all.\n      // So we should always recalculate offset afterwards.\n\n\n      var sizeJustIncreasedFromZero = (prevProps.width === 0 || prevProps.height === 0) && height > 0 && width > 0; // Update scroll offsets if the current :scrollToColumn or :scrollToRow values requires it\n      // @TODO Do we also need this check or can the one in componentWillUpdate() suffice?\n\n      if (this._recomputeScrollLeftFlag) {\n        this._recomputeScrollLeftFlag = false;\n\n        this._updateScrollLeftForScrollToColumn(this.props);\n      } else {\n        updateScrollIndexHelper({\n          cellSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,\n          previousCellsCount: prevProps.columnCount,\n          previousCellSize: prevProps.columnWidth,\n          previousScrollToAlignment: prevProps.scrollToAlignment,\n          previousScrollToIndex: prevProps.scrollToColumn,\n          previousSize: prevProps.width,\n          scrollOffset: scrollLeft,\n          scrollToAlignment: scrollToAlignment,\n          scrollToIndex: scrollToColumn,\n          size: width,\n          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,\n          updateScrollIndexCallback: function updateScrollIndexCallback() {\n            return _this2._updateScrollLeftForScrollToColumn(_this2.props);\n          }\n        });\n      }\n\n      if (this._recomputeScrollTopFlag) {\n        this._recomputeScrollTopFlag = false;\n\n        this._updateScrollTopForScrollToRow(this.props);\n      } else {\n        updateScrollIndexHelper({\n          cellSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,\n          previousCellsCount: prevProps.rowCount,\n          previousCellSize: prevProps.rowHeight,\n          previousScrollToAlignment: prevProps.scrollToAlignment,\n          previousScrollToIndex: prevProps.scrollToRow,\n          previousSize: prevProps.height,\n          scrollOffset: scrollTop,\n          scrollToAlignment: scrollToAlignment,\n          scrollToIndex: scrollToRow,\n          size: height,\n          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,\n          updateScrollIndexCallback: function updateScrollIndexCallback() {\n            return _this2._updateScrollTopForScrollToRow(_this2.props);\n          }\n        });\n      } // Update onRowsRendered callback if start/stop indices have changed\n\n\n      this._invokeOnGridRenderedHelper(); // Changes to :scrollLeft or :scrollTop should also notify :onScroll listeners\n\n\n      if (scrollLeft !== prevState.scrollLeft || scrollTop !== prevState.scrollTop) {\n        var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n        var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n\n        this._invokeOnScrollMemoizer({\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          totalColumnsWidth: totalColumnsWidth,\n          totalRowsHeight: totalRowsHeight\n        });\n      }\n\n      this._maybeCallOnScrollbarPresenceChange();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this._disablePointerEventsTimeoutId) {\n        cancelAnimationTimeout(this._disablePointerEventsTimeoutId);\n      }\n    }\n    /**\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) Empty content (0 rows or columns)\n     * 2) New scroll props overriding the current state\n     * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props6 = this.props,\n          autoContainerWidth = _this$props6.autoContainerWidth,\n          autoHeight = _this$props6.autoHeight,\n          autoWidth = _this$props6.autoWidth,\n          className = _this$props6.className,\n          containerProps = _this$props6.containerProps,\n          containerRole = _this$props6.containerRole,\n          containerStyle = _this$props6.containerStyle,\n          height = _this$props6.height,\n          id = _this$props6.id,\n          noContentRenderer = _this$props6.noContentRenderer,\n          role = _this$props6.role,\n          style = _this$props6.style,\n          tabIndex = _this$props6.tabIndex,\n          width = _this$props6.width;\n      var _this$state2 = this.state,\n          instanceProps = _this$state2.instanceProps,\n          needToResetStyleCache = _this$state2.needToResetStyleCache;\n\n      var isScrolling = this._isScrolling();\n\n      var gridStyle = {\n        boxSizing: 'border-box',\n        direction: 'ltr',\n        height: autoHeight ? 'auto' : height,\n        position: 'relative',\n        width: autoWidth ? 'auto' : width,\n        WebkitOverflowScrolling: 'touch',\n        willChange: 'transform'\n      };\n\n      if (needToResetStyleCache) {\n        this._styleCache = {};\n      } // calculate _styleCache here\n      // if state.isScrolling (not from _isScrolling) then reset\n\n\n      if (!this.state.isScrolling) {\n        this._resetStyleCache();\n      } // calculate children to render here\n\n\n      this._calculateChildrenToRender(this.props, this.state);\n\n      var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n      var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize(); // Force browser to hide scrollbars when we know they aren't necessary.\n      // Otherwise once scrollbars appear they may not disappear again.\n      // For more info see issue #116\n\n      var verticalScrollBarSize = totalRowsHeight > height ? instanceProps.scrollbarSize : 0;\n      var horizontalScrollBarSize = totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;\n\n      if (horizontalScrollBarSize !== this._horizontalScrollBarSize || verticalScrollBarSize !== this._verticalScrollBarSize) {\n        this._horizontalScrollBarSize = horizontalScrollBarSize;\n        this._verticalScrollBarSize = verticalScrollBarSize;\n        this._scrollbarPresenceChanged = true;\n      } // Also explicitly init styles to 'auto' if scrollbars are required.\n      // This works around an obscure edge case where external CSS styles have not yet been loaded,\n      // But an initial scroll index of offset is set as an external prop.\n      // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.\n      // This was originally reported via clauderic/react-infinite-calendar/issues/23\n\n\n      gridStyle.overflowX = totalColumnsWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';\n      gridStyle.overflowY = totalRowsHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';\n      var childrenToDisplay = this._childrenToDisplay;\n      var showNoContentRenderer = childrenToDisplay.length === 0 && height > 0 && width > 0;\n      return React.createElement(\"div\", _extends({\n        ref: this._setScrollingContainerRef\n      }, containerProps, {\n        \"aria-label\": this.props['aria-label'],\n        \"aria-readonly\": this.props['aria-readonly'],\n        className: clsx('ReactVirtualized__Grid', className),\n        id: id,\n        onScroll: this._onScroll,\n        role: role,\n        style: _objectSpread({}, gridStyle, {}, style),\n        tabIndex: tabIndex\n      }), childrenToDisplay.length > 0 && React.createElement(\"div\", {\n        className: \"ReactVirtualized__Grid__innerScrollContainer\",\n        role: containerRole,\n        style: _objectSpread({\n          width: autoContainerWidth ? 'auto' : totalColumnsWidth,\n          height: totalRowsHeight,\n          maxWidth: totalColumnsWidth,\n          maxHeight: totalRowsHeight,\n          overflow: 'hidden',\n          pointerEvents: isScrolling ? 'none' : '',\n          position: 'relative'\n        }, containerStyle)\n      }, childrenToDisplay), showNoContentRenderer && noContentRenderer());\n    }\n    /* ---------------------------- Helper methods ---------------------------- */\n\n  }, {\n    key: \"_calculateChildrenToRender\",\n    value: function _calculateChildrenToRender() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      var cellRenderer = props.cellRenderer,\n          cellRangeRenderer = props.cellRangeRenderer,\n          columnCount = props.columnCount,\n          deferredMeasurementCache = props.deferredMeasurementCache,\n          height = props.height,\n          overscanColumnCount = props.overscanColumnCount,\n          overscanIndicesGetter = props.overscanIndicesGetter,\n          overscanRowCount = props.overscanRowCount,\n          rowCount = props.rowCount,\n          width = props.width,\n          isScrollingOptOut = props.isScrollingOptOut;\n      var scrollDirectionHorizontal = state.scrollDirectionHorizontal,\n          scrollDirectionVertical = state.scrollDirectionVertical,\n          instanceProps = state.instanceProps;\n      var scrollTop = this._initialScrollTop > 0 ? this._initialScrollTop : state.scrollTop;\n      var scrollLeft = this._initialScrollLeft > 0 ? this._initialScrollLeft : state.scrollLeft;\n\n      var isScrolling = this._isScrolling(props, state);\n\n      this._childrenToDisplay = []; // Render only enough columns and rows to cover the visible area of the grid.\n\n      if (height > 0 && width > 0) {\n        var visibleColumnIndices = instanceProps.columnSizeAndPositionManager.getVisibleCellRange({\n          containerSize: width,\n          offset: scrollLeft\n        });\n        var visibleRowIndices = instanceProps.rowSizeAndPositionManager.getVisibleCellRange({\n          containerSize: height,\n          offset: scrollTop\n        });\n        var horizontalOffsetAdjustment = instanceProps.columnSizeAndPositionManager.getOffsetAdjustment({\n          containerSize: width,\n          offset: scrollLeft\n        });\n        var verticalOffsetAdjustment = instanceProps.rowSizeAndPositionManager.getOffsetAdjustment({\n          containerSize: height,\n          offset: scrollTop\n        }); // Store for _invokeOnGridRenderedHelper()\n\n        this._renderedColumnStartIndex = visibleColumnIndices.start;\n        this._renderedColumnStopIndex = visibleColumnIndices.stop;\n        this._renderedRowStartIndex = visibleRowIndices.start;\n        this._renderedRowStopIndex = visibleRowIndices.stop;\n        var overscanColumnIndices = overscanIndicesGetter({\n          direction: 'horizontal',\n          cellCount: columnCount,\n          overscanCellsCount: overscanColumnCount,\n          scrollDirection: scrollDirectionHorizontal,\n          startIndex: typeof visibleColumnIndices.start === 'number' ? visibleColumnIndices.start : 0,\n          stopIndex: typeof visibleColumnIndices.stop === 'number' ? visibleColumnIndices.stop : -1\n        });\n        var overscanRowIndices = overscanIndicesGetter({\n          direction: 'vertical',\n          cellCount: rowCount,\n          overscanCellsCount: overscanRowCount,\n          scrollDirection: scrollDirectionVertical,\n          startIndex: typeof visibleRowIndices.start === 'number' ? visibleRowIndices.start : 0,\n          stopIndex: typeof visibleRowIndices.stop === 'number' ? visibleRowIndices.stop : -1\n        }); // Store for _invokeOnGridRenderedHelper()\n\n        var columnStartIndex = overscanColumnIndices.overscanStartIndex;\n        var columnStopIndex = overscanColumnIndices.overscanStopIndex;\n        var rowStartIndex = overscanRowIndices.overscanStartIndex;\n        var rowStopIndex = overscanRowIndices.overscanStopIndex; // Advanced use-cases (eg CellMeasurer) require batched measurements to determine accurate sizes.\n\n        if (deferredMeasurementCache) {\n          // If rows have a dynamic height, scan the rows we are about to render.\n          // If any have not yet been measured, then we need to render all columns initially,\n          // Because the height of the row is equal to the tallest cell within that row,\n          // (And so we can't know the height without measuring all column-cells first).\n          if (!deferredMeasurementCache.hasFixedHeight()) {\n            for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {\n              if (!deferredMeasurementCache.has(rowIndex, 0)) {\n                columnStartIndex = 0;\n                columnStopIndex = columnCount - 1;\n                break;\n              }\n            }\n          } // If columns have a dynamic width, scan the columns we are about to render.\n          // If any have not yet been measured, then we need to render all rows initially,\n          // Because the width of the column is equal to the widest cell within that column,\n          // (And so we can't know the width without measuring all row-cells first).\n\n\n          if (!deferredMeasurementCache.hasFixedWidth()) {\n            for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {\n              if (!deferredMeasurementCache.has(0, columnIndex)) {\n                rowStartIndex = 0;\n                rowStopIndex = rowCount - 1;\n                break;\n              }\n            }\n          }\n        }\n\n        this._childrenToDisplay = cellRangeRenderer({\n          cellCache: this._cellCache,\n          cellRenderer: cellRenderer,\n          columnSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,\n          columnStartIndex: columnStartIndex,\n          columnStopIndex: columnStopIndex,\n          deferredMeasurementCache: deferredMeasurementCache,\n          horizontalOffsetAdjustment: horizontalOffsetAdjustment,\n          isScrolling: isScrolling,\n          isScrollingOptOut: isScrollingOptOut,\n          parent: this,\n          rowSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,\n          rowStartIndex: rowStartIndex,\n          rowStopIndex: rowStopIndex,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          styleCache: this._styleCache,\n          verticalOffsetAdjustment: verticalOffsetAdjustment,\n          visibleColumnIndices: visibleColumnIndices,\n          visibleRowIndices: visibleRowIndices\n        }); // update the indices\n\n        this._columnStartIndex = columnStartIndex;\n        this._columnStopIndex = columnStopIndex;\n        this._rowStartIndex = rowStartIndex;\n        this._rowStopIndex = rowStopIndex;\n      }\n    }\n    /**\n     * Sets an :isScrolling flag for a small window of time.\n     * This flag is used to disable pointer events on the scrollable portion of the Grid.\n     * This prevents jerky/stuttery mouse-wheel scrolling.\n     */\n\n  }, {\n    key: \"_debounceScrollEnded\",\n    value: function _debounceScrollEnded() {\n      var scrollingResetTimeInterval = this.props.scrollingResetTimeInterval;\n\n      if (this._disablePointerEventsTimeoutId) {\n        cancelAnimationTimeout(this._disablePointerEventsTimeoutId);\n      }\n\n      this._disablePointerEventsTimeoutId = requestAnimationTimeout(this._debounceScrollEndedCallback, scrollingResetTimeInterval);\n    }\n  }, {\n    key: \"_handleInvalidatedGridSize\",\n\n    /**\n     * Check for batched CellMeasurer size invalidations.\n     * This will occur the first time one or more previously unmeasured cells are rendered.\n     */\n    value: function _handleInvalidatedGridSize() {\n      if (typeof this._deferredInvalidateColumnIndex === 'number' && typeof this._deferredInvalidateRowIndex === 'number') {\n        var columnIndex = this._deferredInvalidateColumnIndex;\n        var rowIndex = this._deferredInvalidateRowIndex;\n        this._deferredInvalidateColumnIndex = null;\n        this._deferredInvalidateRowIndex = null;\n        this.recomputeGridSize({\n          columnIndex: columnIndex,\n          rowIndex: rowIndex\n        });\n      }\n    }\n  }, {\n    key: \"_invokeOnScrollMemoizer\",\n    value: function _invokeOnScrollMemoizer(_ref6) {\n      var _this3 = this;\n\n      var scrollLeft = _ref6.scrollLeft,\n          scrollTop = _ref6.scrollTop,\n          totalColumnsWidth = _ref6.totalColumnsWidth,\n          totalRowsHeight = _ref6.totalRowsHeight;\n\n      this._onScrollMemoizer({\n        callback: function callback(_ref7) {\n          var scrollLeft = _ref7.scrollLeft,\n              scrollTop = _ref7.scrollTop;\n          var _this3$props = _this3.props,\n              height = _this3$props.height,\n              onScroll = _this3$props.onScroll,\n              width = _this3$props.width;\n          onScroll({\n            clientHeight: height,\n            clientWidth: width,\n            scrollHeight: totalRowsHeight,\n            scrollLeft: scrollLeft,\n            scrollTop: scrollTop,\n            scrollWidth: totalColumnsWidth\n          });\n        },\n        indices: {\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        }\n      });\n    }\n  }, {\n    key: \"_isScrolling\",\n    value: function _isScrolling() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state; // If isScrolling is defined in props, use it to override the value in state\n      // This is a performance optimization for WindowScroller + Grid\n\n      return Object.hasOwnProperty.call(props, 'isScrolling') ? Boolean(props.isScrolling) : Boolean(state.isScrolling);\n    }\n  }, {\n    key: \"_maybeCallOnScrollbarPresenceChange\",\n    value: function _maybeCallOnScrollbarPresenceChange() {\n      if (this._scrollbarPresenceChanged) {\n        var onScrollbarPresenceChange = this.props.onScrollbarPresenceChange;\n        this._scrollbarPresenceChanged = false;\n        onScrollbarPresenceChange({\n          horizontal: this._horizontalScrollBarSize > 0,\n          size: this.state.instanceProps.scrollbarSize,\n          vertical: this._verticalScrollBarSize > 0\n        });\n      }\n    }\n  }, {\n    key: \"scrollToPosition\",\n\n    /**\n     * Scroll to the specified offset(s).\n     * Useful for animating position changes.\n     */\n    value: function scrollToPosition(_ref8) {\n      var scrollLeft = _ref8.scrollLeft,\n          scrollTop = _ref8.scrollTop;\n\n      var stateUpdate = Grid._getScrollToPositionStateUpdate({\n        prevState: this.state,\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop\n      });\n\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }, {\n    key: \"_getCalculatedScrollLeft\",\n    value: function _getCalculatedScrollLeft() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      return Grid._getCalculatedScrollLeft(props, state);\n    }\n  }, {\n    key: \"_updateScrollLeftForScrollToColumn\",\n    value: function _updateScrollLeftForScrollToColumn() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n      var stateUpdate = Grid._getScrollLeftForScrollToColumnStateUpdate(props, state);\n\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }, {\n    key: \"_getCalculatedScrollTop\",\n    value: function _getCalculatedScrollTop() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      return Grid._getCalculatedScrollTop(props, state);\n    }\n  }, {\n    key: \"_resetStyleCache\",\n    value: function _resetStyleCache() {\n      var styleCache = this._styleCache;\n      var cellCache = this._cellCache;\n      var isScrollingOptOut = this.props.isScrollingOptOut; // Reset cell and style caches once scrolling stops.\n      // This makes Grid simpler to use (since cells commonly change).\n      // And it keeps the caches from growing too large.\n      // Performance is most sensitive when a user is scrolling.\n      // Don't clear visible cells from cellCache if isScrollingOptOut is specified.\n      // This keeps the cellCache to a resonable size.\n\n      this._cellCache = {};\n      this._styleCache = {}; // Copy over the visible cell styles so avoid unnecessary re-render.\n\n      for (var rowIndex = this._rowStartIndex; rowIndex <= this._rowStopIndex; rowIndex++) {\n        for (var columnIndex = this._columnStartIndex; columnIndex <= this._columnStopIndex; columnIndex++) {\n          var key = \"\".concat(rowIndex, \"-\").concat(columnIndex);\n          this._styleCache[key] = styleCache[key];\n\n          if (isScrollingOptOut) {\n            this._cellCache[key] = cellCache[key];\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_updateScrollTopForScrollToRow\",\n    value: function _updateScrollTopForScrollToRow() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n      var stateUpdate = Grid._getScrollTopForScrollToRowStateUpdate(props, state);\n\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      var newState = {};\n\n      if (nextProps.columnCount === 0 && prevState.scrollLeft !== 0 || nextProps.rowCount === 0 && prevState.scrollTop !== 0) {\n        newState.scrollLeft = 0;\n        newState.scrollTop = 0; // only use scroll{Left,Top} from props if scrollTo{Column,Row} isn't specified\n        // scrollTo{Column,Row} should override scroll{Left,Top}\n      } else if (nextProps.scrollLeft !== prevState.scrollLeft && nextProps.scrollToColumn < 0 || nextProps.scrollTop !== prevState.scrollTop && nextProps.scrollToRow < 0) {\n        Object.assign(newState, Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: nextProps.scrollLeft,\n          scrollTop: nextProps.scrollTop\n        }));\n      }\n\n      var instanceProps = prevState.instanceProps; // Initially we should not clearStyleCache\n\n      newState.needToResetStyleCache = false;\n\n      if (nextProps.columnWidth !== instanceProps.prevColumnWidth || nextProps.rowHeight !== instanceProps.prevRowHeight) {\n        // Reset cache. set it to {} in render\n        newState.needToResetStyleCache = true;\n      }\n\n      instanceProps.columnSizeAndPositionManager.configure({\n        cellCount: nextProps.columnCount,\n        estimatedCellSize: Grid._getEstimatedColumnSize(nextProps),\n        cellSizeGetter: Grid._wrapSizeGetter(nextProps.columnWidth)\n      });\n      instanceProps.rowSizeAndPositionManager.configure({\n        cellCount: nextProps.rowCount,\n        estimatedCellSize: Grid._getEstimatedRowSize(nextProps),\n        cellSizeGetter: Grid._wrapSizeGetter(nextProps.rowHeight)\n      });\n\n      if (instanceProps.prevColumnCount === 0 || instanceProps.prevRowCount === 0) {\n        instanceProps.prevColumnCount = 0;\n        instanceProps.prevRowCount = 0;\n      } // If scrolling is controlled outside this component, clear cache when scrolling stops\n\n\n      if (nextProps.autoHeight && nextProps.isScrolling === false && instanceProps.prevIsScrolling === true) {\n        Object.assign(newState, {\n          isScrolling: false\n        });\n      }\n\n      var maybeStateA;\n      var maybeStateB;\n      calculateSizeAndPositionDataAndUpdateScrollOffset({\n        cellCount: instanceProps.prevColumnCount,\n        cellSize: typeof instanceProps.prevColumnWidth === 'number' ? instanceProps.prevColumnWidth : null,\n        computeMetadataCallback: function computeMetadataCallback() {\n          return instanceProps.columnSizeAndPositionManager.resetCell(0);\n        },\n        computeMetadataCallbackProps: nextProps,\n        nextCellsCount: nextProps.columnCount,\n        nextCellSize: typeof nextProps.columnWidth === 'number' ? nextProps.columnWidth : null,\n        nextScrollToIndex: nextProps.scrollToColumn,\n        scrollToIndex: instanceProps.prevScrollToColumn,\n        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {\n          maybeStateA = Grid._getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState);\n        }\n      });\n      calculateSizeAndPositionDataAndUpdateScrollOffset({\n        cellCount: instanceProps.prevRowCount,\n        cellSize: typeof instanceProps.prevRowHeight === 'number' ? instanceProps.prevRowHeight : null,\n        computeMetadataCallback: function computeMetadataCallback() {\n          return instanceProps.rowSizeAndPositionManager.resetCell(0);\n        },\n        computeMetadataCallbackProps: nextProps,\n        nextCellsCount: nextProps.rowCount,\n        nextCellSize: typeof nextProps.rowHeight === 'number' ? nextProps.rowHeight : null,\n        nextScrollToIndex: nextProps.scrollToRow,\n        scrollToIndex: instanceProps.prevScrollToRow,\n        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {\n          maybeStateB = Grid._getScrollTopForScrollToRowStateUpdate(nextProps, prevState);\n        }\n      });\n      instanceProps.prevColumnCount = nextProps.columnCount;\n      instanceProps.prevColumnWidth = nextProps.columnWidth;\n      instanceProps.prevIsScrolling = nextProps.isScrolling === true;\n      instanceProps.prevRowCount = nextProps.rowCount;\n      instanceProps.prevRowHeight = nextProps.rowHeight;\n      instanceProps.prevScrollToColumn = nextProps.scrollToColumn;\n      instanceProps.prevScrollToRow = nextProps.scrollToRow; // getting scrollBarSize (moved from componentWillMount)\n\n      instanceProps.scrollbarSize = nextProps.getScrollbarSize();\n\n      if (instanceProps.scrollbarSize === undefined) {\n        instanceProps.scrollbarSizeMeasured = false;\n        instanceProps.scrollbarSize = 0;\n      } else {\n        instanceProps.scrollbarSizeMeasured = true;\n      }\n\n      newState.instanceProps = instanceProps;\n      return _objectSpread({}, newState, {}, maybeStateA, {}, maybeStateB);\n    }\n  }, {\n    key: \"_getEstimatedColumnSize\",\n    value: function _getEstimatedColumnSize(props) {\n      return typeof props.columnWidth === 'number' ? props.columnWidth : props.estimatedColumnSize;\n    }\n  }, {\n    key: \"_getEstimatedRowSize\",\n    value: function _getEstimatedRowSize(props) {\n      return typeof props.rowHeight === 'number' ? props.rowHeight : props.estimatedRowSize;\n    }\n  }, {\n    key: \"_getScrollToPositionStateUpdate\",\n\n    /**\n     * Get the updated state after scrolling to\n     * scrollLeft and scrollTop\n     */\n    value: function _getScrollToPositionStateUpdate(_ref9) {\n      var prevState = _ref9.prevState,\n          scrollLeft = _ref9.scrollLeft,\n          scrollTop = _ref9.scrollTop;\n      var newState = {\n        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\n      };\n\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0) {\n        newState.scrollDirectionHorizontal = scrollLeft > prevState.scrollLeft ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD;\n        newState.scrollLeft = scrollLeft;\n      }\n\n      if (typeof scrollTop === 'number' && scrollTop >= 0) {\n        newState.scrollDirectionVertical = scrollTop > prevState.scrollTop ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD;\n        newState.scrollTop = scrollTop;\n      }\n\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft || typeof scrollTop === 'number' && scrollTop >= 0 && scrollTop !== prevState.scrollTop) {\n        return newState;\n      }\n\n      return {};\n    }\n  }, {\n    key: \"_wrapSizeGetter\",\n    value: function _wrapSizeGetter(value) {\n      return typeof value === 'function' ? value : function () {\n        return value;\n      };\n    }\n  }, {\n    key: \"_getCalculatedScrollLeft\",\n    value: function _getCalculatedScrollLeft(nextProps, prevState) {\n      var columnCount = nextProps.columnCount,\n          height = nextProps.height,\n          scrollToAlignment = nextProps.scrollToAlignment,\n          scrollToColumn = nextProps.scrollToColumn,\n          width = nextProps.width;\n      var scrollLeft = prevState.scrollLeft,\n          instanceProps = prevState.instanceProps;\n\n      if (columnCount > 0) {\n        var finalColumn = columnCount - 1;\n        var targetIndex = scrollToColumn < 0 ? finalColumn : Math.min(finalColumn, scrollToColumn);\n        var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n        var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalRowsHeight > height ? instanceProps.scrollbarSize : 0;\n        return instanceProps.columnSizeAndPositionManager.getUpdatedOffsetForIndex({\n          align: scrollToAlignment,\n          containerSize: width - scrollBarSize,\n          currentOffset: scrollLeft,\n          targetIndex: targetIndex\n        });\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"_getScrollLeftForScrollToColumnStateUpdate\",\n    value: function _getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState) {\n      var scrollLeft = prevState.scrollLeft;\n\n      var calculatedScrollLeft = Grid._getCalculatedScrollLeft(nextProps, prevState);\n\n      if (typeof calculatedScrollLeft === 'number' && calculatedScrollLeft >= 0 && scrollLeft !== calculatedScrollLeft) {\n        return Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: calculatedScrollLeft,\n          scrollTop: -1\n        });\n      }\n\n      return {};\n    }\n  }, {\n    key: \"_getCalculatedScrollTop\",\n    value: function _getCalculatedScrollTop(nextProps, prevState) {\n      var height = nextProps.height,\n          rowCount = nextProps.rowCount,\n          scrollToAlignment = nextProps.scrollToAlignment,\n          scrollToRow = nextProps.scrollToRow,\n          width = nextProps.width;\n      var scrollTop = prevState.scrollTop,\n          instanceProps = prevState.instanceProps;\n\n      if (rowCount > 0) {\n        var finalRow = rowCount - 1;\n        var targetIndex = scrollToRow < 0 ? finalRow : Math.min(finalRow, scrollToRow);\n        var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n        var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;\n        return instanceProps.rowSizeAndPositionManager.getUpdatedOffsetForIndex({\n          align: scrollToAlignment,\n          containerSize: height - scrollBarSize,\n          currentOffset: scrollTop,\n          targetIndex: targetIndex\n        });\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"_getScrollTopForScrollToRowStateUpdate\",\n    value: function _getScrollTopForScrollToRowStateUpdate(nextProps, prevState) {\n      var scrollTop = prevState.scrollTop;\n\n      var calculatedScrollTop = Grid._getCalculatedScrollTop(nextProps, prevState);\n\n      if (typeof calculatedScrollTop === 'number' && calculatedScrollTop >= 0 && scrollTop !== calculatedScrollTop) {\n        return Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: -1,\n          scrollTop: calculatedScrollTop\n        });\n      }\n\n      return {};\n    }\n  }]);\n\n  return Grid;\n}(React.PureComponent), _defineProperty(_class, \"propTypes\", process.env.NODE_ENV === 'production' ? null : {\n  \"aria-label\": PropTypes.string.isRequired,\n  \"aria-readonly\": PropTypes.bool,\n\n  /**\n   * Set the width of the inner scrollable container to 'auto'.\n   * This is useful for single-column Grids to ensure that the column doesn't extend below a vertical scrollbar.\n   */\n  \"autoContainerWidth\": PropTypes.bool.isRequired,\n\n  /**\n   * Removes fixed height from the scrollingContainer so that the total height of rows can stretch the window.\n   * Intended for use with WindowScroller\n   */\n  \"autoHeight\": PropTypes.bool.isRequired,\n\n  /**\n   * Removes fixed width from the scrollingContainer so that the total width of rows can stretch the window.\n   * Intended for use with WindowScroller\n   */\n  \"autoWidth\": PropTypes.bool.isRequired,\n\n  /** Responsible for rendering a cell given an row and column index.  */\n  \"cellRenderer\": function cellRenderer() {\n    return (typeof bpfrpt_proptype_CellRenderer === \"function\" ? bpfrpt_proptype_CellRenderer.isRequired ? bpfrpt_proptype_CellRenderer.isRequired : bpfrpt_proptype_CellRenderer : PropTypes.shape(bpfrpt_proptype_CellRenderer).isRequired).apply(this, arguments);\n  },\n\n  /** Responsible for rendering a group of cells given their index ranges.  */\n  \"cellRangeRenderer\": function cellRangeRenderer() {\n    return (typeof bpfrpt_proptype_CellRangeRenderer === \"function\" ? bpfrpt_proptype_CellRangeRenderer.isRequired ? bpfrpt_proptype_CellRangeRenderer.isRequired : bpfrpt_proptype_CellRangeRenderer : PropTypes.shape(bpfrpt_proptype_CellRangeRenderer).isRequired).apply(this, arguments);\n  },\n\n  /** Optional custom CSS class name to attach to root Grid element.  */\n  \"className\": PropTypes.string,\n\n  /** Number of columns in grid.  */\n  \"columnCount\": PropTypes.number.isRequired,\n\n  /** Either a fixed column width (number) or a function that returns the width of a column given its index.  */\n  \"columnWidth\": function columnWidth() {\n    return (typeof bpfrpt_proptype_CellSize === \"function\" ? bpfrpt_proptype_CellSize.isRequired ? bpfrpt_proptype_CellSize.isRequired : bpfrpt_proptype_CellSize : PropTypes.shape(bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);\n  },\n\n  /** Unfiltered props for the Grid container. */\n  \"containerProps\": PropTypes.object,\n\n  /** ARIA role for the cell-container.  */\n  \"containerRole\": PropTypes.string.isRequired,\n\n  /** Optional inline style applied to inner cell-container */\n  \"containerStyle\": PropTypes.object.isRequired,\n\n  /**\n   * If CellMeasurer is used to measure this Grid's children, this should be a pointer to its CellMeasurerCache.\n   * A shared CellMeasurerCache reference enables Grid and CellMeasurer to share measurement data.\n   */\n  \"deferredMeasurementCache\": PropTypes.object,\n\n  /**\n   * Used to estimate the total width of a Grid before all of its columns have actually been measured.\n   * The estimated total width is adjusted as columns are rendered.\n   */\n  \"estimatedColumnSize\": PropTypes.number.isRequired,\n\n  /**\n   * Used to estimate the total height of a Grid before all of its rows have actually been measured.\n   * The estimated total height is adjusted as rows are rendered.\n   */\n  \"estimatedRowSize\": PropTypes.number.isRequired,\n\n  /** Exposed for testing purposes only.  */\n  \"getScrollbarSize\": PropTypes.func.isRequired,\n\n  /** Height of Grid; this property determines the number of visible (vs virtualized) rows.  */\n  \"height\": PropTypes.number.isRequired,\n\n  /** Optional custom id to attach to root Grid element.  */\n  \"id\": PropTypes.string,\n\n  /**\n   * Override internal is-scrolling state tracking.\n   * This property is primarily intended for use with the WindowScroller component.\n   */\n  \"isScrolling\": PropTypes.bool,\n\n  /**\n   * Opt-out of isScrolling param passed to cellRangeRenderer.\n   * To avoid the extra render when scroll stops.\n   */\n  \"isScrollingOptOut\": PropTypes.bool.isRequired,\n\n  /** Optional renderer to be used in place of rows when either :rowCount or :columnCount is 0.  */\n  \"noContentRenderer\": function noContentRenderer() {\n    return (typeof bpfrpt_proptype_NoContentRenderer === \"function\" ? bpfrpt_proptype_NoContentRenderer.isRequired ? bpfrpt_proptype_NoContentRenderer.isRequired : bpfrpt_proptype_NoContentRenderer : PropTypes.shape(bpfrpt_proptype_NoContentRenderer).isRequired).apply(this, arguments);\n  },\n\n  /**\n   * Callback invoked whenever the scroll offset changes within the inner scrollable region.\n   * This callback can be used to sync scrolling between lists, tables, or grids.\n   */\n  \"onScroll\": PropTypes.func.isRequired,\n\n  /**\n   * Called whenever a horizontal or vertical scrollbar is added or removed.\n   * This prop is not intended for end-user use;\n   * It is used by MultiGrid to support fixed-row/fixed-column scroll syncing.\n   */\n  \"onScrollbarPresenceChange\": PropTypes.func.isRequired,\n\n  /** Callback invoked with information about the section of the Grid that was just rendered.  */\n  \"onSectionRendered\": PropTypes.func.isRequired,\n\n  /**\n   * Number of columns to render before/after the visible section of the grid.\n   * These columns can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.\n   */\n  \"overscanColumnCount\": PropTypes.number.isRequired,\n\n  /**\n   * Calculates the number of cells to overscan before and after a specified range.\n   * This function ensures that overscanning doesn't exceed the available cells.\n   */\n  \"overscanIndicesGetter\": function overscanIndicesGetter() {\n    return (typeof bpfrpt_proptype_OverscanIndicesGetter === \"function\" ? bpfrpt_proptype_OverscanIndicesGetter.isRequired ? bpfrpt_proptype_OverscanIndicesGetter.isRequired : bpfrpt_proptype_OverscanIndicesGetter : PropTypes.shape(bpfrpt_proptype_OverscanIndicesGetter).isRequired).apply(this, arguments);\n  },\n\n  /**\n   * Number of rows to render above/below the visible section of the grid.\n   * These rows can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.\n   */\n  \"overscanRowCount\": PropTypes.number.isRequired,\n\n  /** ARIA role for the grid element.  */\n  \"role\": PropTypes.string.isRequired,\n\n  /**\n   * Either a fixed row height (number) or a function that returns the height of a row given its index.\n   * Should implement the following interface: ({ index: number }): number\n   */\n  \"rowHeight\": function rowHeight() {\n    return (typeof bpfrpt_proptype_CellSize === \"function\" ? bpfrpt_proptype_CellSize.isRequired ? bpfrpt_proptype_CellSize.isRequired : bpfrpt_proptype_CellSize : PropTypes.shape(bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);\n  },\n\n  /** Number of rows in grid.  */\n  \"rowCount\": PropTypes.number.isRequired,\n\n  /** Wait this amount of time after the last scroll event before resetting Grid `pointer-events`. */\n  \"scrollingResetTimeInterval\": PropTypes.number.isRequired,\n\n  /** Horizontal offset. */\n  \"scrollLeft\": PropTypes.number,\n\n  /**\n   * Controls scroll-to-cell behavior of the Grid.\n   * The default (\"auto\") scrolls the least amount possible to ensure that the specified cell is fully visible.\n   * Use \"start\" to align cells to the top/left of the Grid and \"end\" to align bottom/right.\n   */\n  \"scrollToAlignment\": function scrollToAlignment() {\n    return (typeof bpfrpt_proptype_Alignment === \"function\" ? bpfrpt_proptype_Alignment.isRequired ? bpfrpt_proptype_Alignment.isRequired : bpfrpt_proptype_Alignment : PropTypes.shape(bpfrpt_proptype_Alignment).isRequired).apply(this, arguments);\n  },\n\n  /** Column index to ensure visible (by forcefully scrolling if necessary) */\n  \"scrollToColumn\": PropTypes.number.isRequired,\n\n  /** Vertical offset. */\n  \"scrollTop\": PropTypes.number,\n\n  /** Row index to ensure visible (by forcefully scrolling if necessary) */\n  \"scrollToRow\": PropTypes.number.isRequired,\n\n  /** Optional inline style */\n  \"style\": PropTypes.object.isRequired,\n\n  /** Tab index for focus */\n  \"tabIndex\": PropTypes.number,\n\n  /** Width of Grid; this property determines the number of visible (vs virtualized) columns.  */\n  \"width\": PropTypes.number.isRequired\n}), _temp);\n\n_defineProperty(Grid, \"defaultProps\", {\n  'aria-label': 'grid',\n  'aria-readonly': true,\n  autoContainerWidth: false,\n  autoHeight: false,\n  autoWidth: false,\n  cellRangeRenderer: defaultCellRangeRenderer,\n  containerRole: 'rowgroup',\n  containerStyle: {},\n  estimatedColumnSize: 100,\n  estimatedRowSize: 30,\n  getScrollbarSize: scrollbarSize,\n  noContentRenderer: renderNull,\n  onScroll: function onScroll() {},\n  onScrollbarPresenceChange: function onScrollbarPresenceChange() {},\n  onSectionRendered: function onSectionRendered() {},\n  overscanColumnCount: 0,\n  overscanIndicesGetter: defaultOverscanIndicesGetter,\n  overscanRowCount: 10,\n  role: 'grid',\n  scrollingResetTimeInterval: DEFAULT_SCROLLING_RESET_TIME_INTERVAL,\n  scrollToAlignment: 'auto',\n  scrollToColumn: -1,\n  scrollToRow: -1,\n  style: {},\n  tabIndex: 0,\n  isScrollingOptOut: false\n});\n\npolyfill(Grid);\nexport default Grid;\nimport { bpfrpt_proptype_CellRenderer } from \"./types\";\nimport { bpfrpt_proptype_CellRangeRenderer } from \"./types\";\nimport { bpfrpt_proptype_CellPosition } from \"./types\";\nimport { bpfrpt_proptype_CellSize } from \"./types\";\nimport { bpfrpt_proptype_CellSizeGetter } from \"./types\";\nimport { bpfrpt_proptype_NoContentRenderer } from \"./types\";\nimport { bpfrpt_proptype_Scroll } from \"./types\";\nimport { bpfrpt_proptype_ScrollbarPresenceChange } from \"./types\";\nimport { bpfrpt_proptype_RenderedSection } from \"./types\";\nimport { bpfrpt_proptype_OverscanIndicesGetter } from \"./types\";\nimport { bpfrpt_proptype_Alignment } from \"./types\";\nimport { bpfrpt_proptype_CellCache } from \"./types\";\nimport { bpfrpt_proptype_StyleCache } from \"./types\";\nimport { bpfrpt_proptype_AnimationTimeoutId } from \"../utils/requestAnimationTimeout\";\nimport PropTypes from \"prop-types\";","map":{"version":3,"names":["_extends","_classCallCheck","_createClass","_possibleConstructorReturn","_getPrototypeOf","_assertThisInitialized","_inherits","_defineProperty","_class","_temp","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","React","clsx","calculateSizeAndPositionDataAndUpdateScrollOffset","ScalingCellSizeAndPositionManager","createCallbackMemoizer","defaultOverscanIndicesGetter","SCROLL_DIRECTION_BACKWARD","SCROLL_DIRECTION_FORWARD","updateScrollIndexHelper","defaultCellRangeRenderer","scrollbarSize","polyfill","requestAnimationTimeout","cancelAnimationTimeout","DEFAULT_SCROLLING_RESET_TIME_INTERVAL","SCROLL_POSITION_CHANGE_REASONS","OBSERVED","REQUESTED","renderNull","Grid","_React$PureComponent","props","_this","call","_disablePointerEventsTimeoutId","setState","isScrolling","needToResetStyleCache","onSectionRendered","_onGridRenderedMemoizer","callback","indices","columnOverscanStartIndex","_columnStartIndex","columnOverscanStopIndex","_columnStopIndex","columnStartIndex","_renderedColumnStartIndex","columnStopIndex","_renderedColumnStopIndex","rowOverscanStartIndex","_rowStartIndex","rowOverscanStopIndex","_rowStopIndex","rowStartIndex","_renderedRowStartIndex","rowStopIndex","_renderedRowStopIndex","ref","_scrollingContainer","event","handleScrollEvent","columnSizeAndPositionManager","cellCount","columnCount","cellSizeGetter","params","_wrapSizeGetter","columnWidth","estimatedCellSize","_getEstimatedColumnSize","rowSizeAndPositionManager","rowCount","rowHeight","_getEstimatedRowSize","state","instanceProps","prevColumnWidth","prevRowHeight","prevColumnCount","prevRowCount","prevIsScrolling","prevScrollToColumn","scrollToColumn","prevScrollToRow","scrollToRow","scrollbarSizeMeasured","scrollDirectionHorizontal","scrollDirectionVertical","scrollLeft","scrollTop","scrollPositionChangeReason","_initialScrollTop","_getCalculatedScrollTop","_initialScrollLeft","_getCalculatedScrollLeft","value","getOffsetForCell","_ref","undefined","_ref$alignment","alignment","scrollToAlignment","_ref$columnIndex","columnIndex","_ref$rowIndex","rowIndex","offsetProps","getTotalRowsHeight","getTotalSize","getTotalColumnsWidth","_ref2","_ref2$scrollLeft","scrollLeftParam","_ref2$scrollTop","scrollTopParam","_debounceScrollEnded","_this$props","autoHeight","autoWidth","height","width","totalRowsHeight","totalColumnsWidth","Math","min","max","newState","_invokeOnScrollMemoizer","invalidateCellSizeAfterRender","_ref3","_deferredInvalidateColumnIndex","_deferredInvalidateRowIndex","measureAllCells","_this$props2","getSizeAndPositionOfCell","recomputeGridSize","_ref4","_ref4$columnIndex","_ref4$rowIndex","_this$props3","resetCell","_recomputeScrollLeftFlag","_recomputeScrollTopFlag","_styleCache","_cellCache","forceUpdate","scrollToCell","_ref5","_updateScrollLeftForScrollToColumn","_updateScrollTopForScrollToRow","componentDidMount","_this$props4","getScrollbarSize","_handleInvalidatedGridSize","prevState","stateUpdate","_getScrollToPositionStateUpdate","sizeIsBiggerThanZero","_invokeOnGridRenderedHelper","_maybeCallOnScrollbarPresenceChange","componentDidUpdate","prevProps","_this2","_this$props5","_this$state","columnOrRowCountJustIncreasedFromZero","sizeJustIncreasedFromZero","cellSizeAndPositionManager","previousCellsCount","previousCellSize","previousScrollToAlignment","previousScrollToIndex","previousSize","scrollOffset","scrollToIndex","size","updateScrollIndexCallback","componentWillUnmount","render","_this$props6","autoContainerWidth","className","containerProps","containerRole","containerStyle","id","noContentRenderer","role","style","tabIndex","_this$state2","_isScrolling","gridStyle","boxSizing","direction","position","WebkitOverflowScrolling","willChange","_resetStyleCache","_calculateChildrenToRender","verticalScrollBarSize","horizontalScrollBarSize","_horizontalScrollBarSize","_verticalScrollBarSize","_scrollbarPresenceChanged","overflowX","overflowY","childrenToDisplay","_childrenToDisplay","showNoContentRenderer","createElement","_setScrollingContainerRef","onScroll","_onScroll","maxWidth","maxHeight","overflow","pointerEvents","cellRenderer","cellRangeRenderer","deferredMeasurementCache","overscanColumnCount","overscanIndicesGetter","overscanRowCount","isScrollingOptOut","visibleColumnIndices","getVisibleCellRange","containerSize","offset","visibleRowIndices","horizontalOffsetAdjustment","getOffsetAdjustment","verticalOffsetAdjustment","start","stop","overscanColumnIndices","overscanCellsCount","scrollDirection","startIndex","stopIndex","overscanRowIndices","overscanStartIndex","overscanStopIndex","hasFixedHeight","has","hasFixedWidth","cellCache","parent","styleCache","scrollingResetTimeInterval","_debounceScrollEndedCallback","_ref6","_this3","_onScrollMemoizer","_ref7","_this3$props","clientHeight","clientWidth","scrollHeight","scrollWidth","hasOwnProperty","Boolean","onScrollbarPresenceChange","horizontal","vertical","scrollToPosition","_ref8","_getScrollLeftForScrollToColumnStateUpdate","concat","_getScrollTopForScrollToRowStateUpdate","getDerivedStateFromProps","nextProps","assign","configure","maybeStateA","maybeStateB","cellSize","computeMetadataCallback","computeMetadataCallbackProps","nextCellsCount","nextCellSize","nextScrollToIndex","updateScrollOffsetForScrollToIndex","estimatedColumnSize","estimatedRowSize","_ref9","finalColumn","targetIndex","scrollBarSize","getUpdatedOffsetForIndex","align","currentOffset","calculatedScrollLeft","finalRow","calculatedScrollTop","PureComponent","process","env","NODE_ENV","PropTypes","string","isRequired","bool","bpfrpt_proptype_CellRenderer","shape","bpfrpt_proptype_CellRangeRenderer","number","bpfrpt_proptype_CellSize","func","bpfrpt_proptype_NoContentRenderer","bpfrpt_proptype_OverscanIndicesGetter","bpfrpt_proptype_Alignment","bpfrpt_proptype_CellPosition","bpfrpt_proptype_CellSizeGetter","bpfrpt_proptype_Scroll","bpfrpt_proptype_ScrollbarPresenceChange","bpfrpt_proptype_RenderedSection","bpfrpt_proptype_CellCache","bpfrpt_proptype_StyleCache","bpfrpt_proptype_AnimationTimeoutId"],"sources":["/Users/stoneye/react_project/circle-app-react-hook/node_modules/react-virtualized/dist/es/Grid/Grid.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nvar _class, _temp;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport * as React from 'react';\nimport clsx from 'clsx';\nimport calculateSizeAndPositionDataAndUpdateScrollOffset from './utils/calculateSizeAndPositionDataAndUpdateScrollOffset';\nimport ScalingCellSizeAndPositionManager from './utils/ScalingCellSizeAndPositionManager';\nimport createCallbackMemoizer from '../utils/createCallbackMemoizer';\nimport defaultOverscanIndicesGetter, { SCROLL_DIRECTION_BACKWARD, SCROLL_DIRECTION_FORWARD } from './defaultOverscanIndicesGetter';\nimport updateScrollIndexHelper from './utils/updateScrollIndexHelper';\nimport defaultCellRangeRenderer from './defaultCellRangeRenderer';\nimport scrollbarSize from 'dom-helpers/scrollbarSize';\nimport { polyfill } from 'react-lifecycles-compat';\nimport { requestAnimationTimeout, cancelAnimationTimeout } from '../utils/requestAnimationTimeout';\n/**\n * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.\n * This improves performance and makes scrolling smoother.\n */\n\nexport var DEFAULT_SCROLLING_RESET_TIME_INTERVAL = 150;\n/**\n * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.\n * This prevents Grid from interrupting mouse-wheel animations (see issue #2).\n */\n\nvar SCROLL_POSITION_CHANGE_REASONS = {\n  OBSERVED: 'observed',\n  REQUESTED: 'requested'\n};\n\nvar renderNull = function renderNull() {\n  return null;\n};\n\n/**\n * Renders tabular data with virtualization along the vertical and horizontal axes.\n * Row heights and column widths must be known ahead of time and specified as properties.\n */\nvar Grid = (_temp = _class =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(Grid, _React$PureComponent);\n\n  // Invokes onSectionRendered callback only when start/stop row or column indices change\n  function Grid(props) {\n    var _this;\n\n    _classCallCheck(this, Grid);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Grid).call(this, props));\n\n    _defineProperty(_assertThisInitialized(_this), \"_onGridRenderedMemoizer\", createCallbackMemoizer());\n\n    _defineProperty(_assertThisInitialized(_this), \"_onScrollMemoizer\", createCallbackMemoizer(false));\n\n    _defineProperty(_assertThisInitialized(_this), \"_deferredInvalidateColumnIndex\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"_deferredInvalidateRowIndex\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"_recomputeScrollLeftFlag\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"_recomputeScrollTopFlag\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"_horizontalScrollBarSize\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_verticalScrollBarSize\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_scrollbarPresenceChanged\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"_scrollingContainer\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_childrenToDisplay\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_columnStartIndex\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_columnStopIndex\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_rowStartIndex\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_rowStopIndex\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_renderedColumnStartIndex\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_renderedColumnStopIndex\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_renderedRowStartIndex\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_renderedRowStopIndex\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_initialScrollTop\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_initialScrollLeft\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_disablePointerEventsTimeoutId\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_styleCache\", {});\n\n    _defineProperty(_assertThisInitialized(_this), \"_cellCache\", {});\n\n    _defineProperty(_assertThisInitialized(_this), \"_debounceScrollEndedCallback\", function () {\n      _this._disablePointerEventsTimeoutId = null; // isScrolling is used to determine if we reset styleCache\n\n      _this.setState({\n        isScrolling: false,\n        needToResetStyleCache: false\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_invokeOnGridRenderedHelper\", function () {\n      var onSectionRendered = _this.props.onSectionRendered;\n\n      _this._onGridRenderedMemoizer({\n        callback: onSectionRendered,\n        indices: {\n          columnOverscanStartIndex: _this._columnStartIndex,\n          columnOverscanStopIndex: _this._columnStopIndex,\n          columnStartIndex: _this._renderedColumnStartIndex,\n          columnStopIndex: _this._renderedColumnStopIndex,\n          rowOverscanStartIndex: _this._rowStartIndex,\n          rowOverscanStopIndex: _this._rowStopIndex,\n          rowStartIndex: _this._renderedRowStartIndex,\n          rowStopIndex: _this._renderedRowStopIndex\n        }\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_setScrollingContainerRef\", function (ref) {\n      _this._scrollingContainer = ref;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_onScroll\", function (event) {\n      // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.\n      // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.\n      // See issue #404 for more information.\n      if (event.target === _this._scrollingContainer) {\n        _this.handleScrollEvent(event.target);\n      }\n    });\n\n    var columnSizeAndPositionManager = new ScalingCellSizeAndPositionManager({\n      cellCount: props.columnCount,\n      cellSizeGetter: function cellSizeGetter(params) {\n        return Grid._wrapSizeGetter(props.columnWidth)(params);\n      },\n      estimatedCellSize: Grid._getEstimatedColumnSize(props)\n    });\n    var rowSizeAndPositionManager = new ScalingCellSizeAndPositionManager({\n      cellCount: props.rowCount,\n      cellSizeGetter: function cellSizeGetter(params) {\n        return Grid._wrapSizeGetter(props.rowHeight)(params);\n      },\n      estimatedCellSize: Grid._getEstimatedRowSize(props)\n    });\n    _this.state = {\n      instanceProps: {\n        columnSizeAndPositionManager: columnSizeAndPositionManager,\n        rowSizeAndPositionManager: rowSizeAndPositionManager,\n        prevColumnWidth: props.columnWidth,\n        prevRowHeight: props.rowHeight,\n        prevColumnCount: props.columnCount,\n        prevRowCount: props.rowCount,\n        prevIsScrolling: props.isScrolling === true,\n        prevScrollToColumn: props.scrollToColumn,\n        prevScrollToRow: props.scrollToRow,\n        scrollbarSize: 0,\n        scrollbarSizeMeasured: false\n      },\n      isScrolling: false,\n      scrollDirectionHorizontal: SCROLL_DIRECTION_FORWARD,\n      scrollDirectionVertical: SCROLL_DIRECTION_FORWARD,\n      scrollLeft: 0,\n      scrollTop: 0,\n      scrollPositionChangeReason: null,\n      needToResetStyleCache: false\n    };\n\n    if (props.scrollToRow > 0) {\n      _this._initialScrollTop = _this._getCalculatedScrollTop(props, _this.state);\n    }\n\n    if (props.scrollToColumn > 0) {\n      _this._initialScrollLeft = _this._getCalculatedScrollLeft(props, _this.state);\n    }\n\n    return _this;\n  }\n  /**\n   * Gets offsets for a given cell and alignment.\n   */\n\n\n  _createClass(Grid, [{\n    key: \"getOffsetForCell\",\n    value: function getOffsetForCell() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$alignment = _ref.alignment,\n          alignment = _ref$alignment === void 0 ? this.props.scrollToAlignment : _ref$alignment,\n          _ref$columnIndex = _ref.columnIndex,\n          columnIndex = _ref$columnIndex === void 0 ? this.props.scrollToColumn : _ref$columnIndex,\n          _ref$rowIndex = _ref.rowIndex,\n          rowIndex = _ref$rowIndex === void 0 ? this.props.scrollToRow : _ref$rowIndex;\n\n      var offsetProps = _objectSpread({}, this.props, {\n        scrollToAlignment: alignment,\n        scrollToColumn: columnIndex,\n        scrollToRow: rowIndex\n      });\n\n      return {\n        scrollLeft: this._getCalculatedScrollLeft(offsetProps),\n        scrollTop: this._getCalculatedScrollTop(offsetProps)\n      };\n    }\n    /**\n     * Gets estimated total rows' height.\n     */\n\n  }, {\n    key: \"getTotalRowsHeight\",\n    value: function getTotalRowsHeight() {\n      return this.state.instanceProps.rowSizeAndPositionManager.getTotalSize();\n    }\n    /**\n     * Gets estimated total columns' width.\n     */\n\n  }, {\n    key: \"getTotalColumnsWidth\",\n    value: function getTotalColumnsWidth() {\n      return this.state.instanceProps.columnSizeAndPositionManager.getTotalSize();\n    }\n    /**\n     * This method handles a scroll event originating from an external scroll control.\n     * It's an advanced method and should probably not be used unless you're implementing a custom scroll-bar solution.\n     */\n\n  }, {\n    key: \"handleScrollEvent\",\n    value: function handleScrollEvent(_ref2) {\n      var _ref2$scrollLeft = _ref2.scrollLeft,\n          scrollLeftParam = _ref2$scrollLeft === void 0 ? 0 : _ref2$scrollLeft,\n          _ref2$scrollTop = _ref2.scrollTop,\n          scrollTopParam = _ref2$scrollTop === void 0 ? 0 : _ref2$scrollTop;\n\n      // On iOS, we can arrive at negative offsets by swiping past the start.\n      // To prevent flicker here, we make playing in the negative offset zone cause nothing to happen.\n      if (scrollTopParam < 0) {\n        return;\n      } // Prevent pointer events from interrupting a smooth scroll\n\n\n      this._debounceScrollEnded();\n\n      var _this$props = this.props,\n          autoHeight = _this$props.autoHeight,\n          autoWidth = _this$props.autoWidth,\n          height = _this$props.height,\n          width = _this$props.width;\n      var instanceProps = this.state.instanceProps; // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,\n      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.\n      // This causes a series of rapid renders that is slow for long lists.\n      // We can avoid that by doing some simple bounds checking to ensure that scroll offsets never exceed their bounds.\n\n      var scrollbarSize = instanceProps.scrollbarSize;\n      var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n      var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n      var scrollLeft = Math.min(Math.max(0, totalColumnsWidth - width + scrollbarSize), scrollLeftParam);\n      var scrollTop = Math.min(Math.max(0, totalRowsHeight - height + scrollbarSize), scrollTopParam); // Certain devices (like Apple touchpad) rapid-fire duplicate events.\n      // Don't force a re-render if this is the case.\n      // The mouse may move faster then the animation frame does.\n      // Use requestAnimationFrame to avoid over-updating.\n\n      if (this.state.scrollLeft !== scrollLeft || this.state.scrollTop !== scrollTop) {\n        // Track scrolling direction so we can more efficiently overscan rows to reduce empty space around the edges while scrolling.\n        // Don't change direction for an axis unless scroll offset has changed.\n        var scrollDirectionHorizontal = scrollLeft !== this.state.scrollLeft ? scrollLeft > this.state.scrollLeft ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionHorizontal;\n        var scrollDirectionVertical = scrollTop !== this.state.scrollTop ? scrollTop > this.state.scrollTop ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionVertical;\n        var newState = {\n          isScrolling: true,\n          scrollDirectionHorizontal: scrollDirectionHorizontal,\n          scrollDirectionVertical: scrollDirectionVertical,\n          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.OBSERVED\n        };\n\n        if (!autoHeight) {\n          newState.scrollTop = scrollTop;\n        }\n\n        if (!autoWidth) {\n          newState.scrollLeft = scrollLeft;\n        }\n\n        newState.needToResetStyleCache = false;\n        this.setState(newState);\n      }\n\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop,\n        totalColumnsWidth: totalColumnsWidth,\n        totalRowsHeight: totalRowsHeight\n      });\n    }\n    /**\n     * Invalidate Grid size and recompute visible cells.\n     * This is a deferred wrapper for recomputeGridSize().\n     * It sets a flag to be evaluated on cDM/cDU to avoid unnecessary renders.\n     * This method is intended for advanced use-cases like CellMeasurer.\n     */\n    // @TODO (bvaughn) Add automated test coverage for this.\n\n  }, {\n    key: \"invalidateCellSizeAfterRender\",\n    value: function invalidateCellSizeAfterRender(_ref3) {\n      var columnIndex = _ref3.columnIndex,\n          rowIndex = _ref3.rowIndex;\n      this._deferredInvalidateColumnIndex = typeof this._deferredInvalidateColumnIndex === 'number' ? Math.min(this._deferredInvalidateColumnIndex, columnIndex) : columnIndex;\n      this._deferredInvalidateRowIndex = typeof this._deferredInvalidateRowIndex === 'number' ? Math.min(this._deferredInvalidateRowIndex, rowIndex) : rowIndex;\n    }\n    /**\n     * Pre-measure all columns and rows in a Grid.\n     * Typically cells are only measured as needed and estimated sizes are used for cells that have not yet been measured.\n     * This method ensures that the next call to getTotalSize() returns an exact size (as opposed to just an estimated one).\n     */\n\n  }, {\n    key: \"measureAllCells\",\n    value: function measureAllCells() {\n      var _this$props2 = this.props,\n          columnCount = _this$props2.columnCount,\n          rowCount = _this$props2.rowCount;\n      var instanceProps = this.state.instanceProps;\n      instanceProps.columnSizeAndPositionManager.getSizeAndPositionOfCell(columnCount - 1);\n      instanceProps.rowSizeAndPositionManager.getSizeAndPositionOfCell(rowCount - 1);\n    }\n    /**\n     * Forced recompute of row heights and column widths.\n     * This function should be called if dynamic column or row sizes have changed but nothing else has.\n     * Since Grid only receives :columnCount and :rowCount it has no way of detecting when the underlying data changes.\n     */\n\n  }, {\n    key: \"recomputeGridSize\",\n    value: function recomputeGridSize() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref4$columnIndex = _ref4.columnIndex,\n          columnIndex = _ref4$columnIndex === void 0 ? 0 : _ref4$columnIndex,\n          _ref4$rowIndex = _ref4.rowIndex,\n          rowIndex = _ref4$rowIndex === void 0 ? 0 : _ref4$rowIndex;\n\n      var _this$props3 = this.props,\n          scrollToColumn = _this$props3.scrollToColumn,\n          scrollToRow = _this$props3.scrollToRow;\n      var instanceProps = this.state.instanceProps;\n      instanceProps.columnSizeAndPositionManager.resetCell(columnIndex);\n      instanceProps.rowSizeAndPositionManager.resetCell(rowIndex); // Cell sizes may be determined by a function property.\n      // In this case the cDU handler can't know if they changed.\n      // Store this flag to let the next cDU pass know it needs to recompute the scroll offset.\n\n      this._recomputeScrollLeftFlag = scrollToColumn >= 0 && (this.state.scrollDirectionHorizontal === SCROLL_DIRECTION_FORWARD ? columnIndex <= scrollToColumn : columnIndex >= scrollToColumn);\n      this._recomputeScrollTopFlag = scrollToRow >= 0 && (this.state.scrollDirectionVertical === SCROLL_DIRECTION_FORWARD ? rowIndex <= scrollToRow : rowIndex >= scrollToRow); // Clear cell cache in case we are scrolling;\n      // Invalid row heights likely mean invalid cached content as well.\n\n      this._styleCache = {};\n      this._cellCache = {};\n      this.forceUpdate();\n    }\n    /**\n     * Ensure column and row are visible.\n     */\n\n  }, {\n    key: \"scrollToCell\",\n    value: function scrollToCell(_ref5) {\n      var columnIndex = _ref5.columnIndex,\n          rowIndex = _ref5.rowIndex;\n      var columnCount = this.props.columnCount;\n      var props = this.props; // Don't adjust scroll offset for single-column grids (eg List, Table).\n      // This can cause a funky scroll offset because of the vertical scrollbar width.\n\n      if (columnCount > 1 && columnIndex !== undefined) {\n        this._updateScrollLeftForScrollToColumn(_objectSpread({}, props, {\n          scrollToColumn: columnIndex\n        }));\n      }\n\n      if (rowIndex !== undefined) {\n        this._updateScrollTopForScrollToRow(_objectSpread({}, props, {\n          scrollToRow: rowIndex\n        }));\n      }\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props4 = this.props,\n          getScrollbarSize = _this$props4.getScrollbarSize,\n          height = _this$props4.height,\n          scrollLeft = _this$props4.scrollLeft,\n          scrollToColumn = _this$props4.scrollToColumn,\n          scrollTop = _this$props4.scrollTop,\n          scrollToRow = _this$props4.scrollToRow,\n          width = _this$props4.width;\n      var instanceProps = this.state.instanceProps; // Reset initial offsets to be ignored in browser\n\n      this._initialScrollTop = 0;\n      this._initialScrollLeft = 0; // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.\n      // We must do this at the start of the method as we may calculate and update scroll position below.\n\n      this._handleInvalidatedGridSize(); // If this component was first rendered server-side, scrollbar size will be undefined.\n      // In that event we need to remeasure.\n\n\n      if (!instanceProps.scrollbarSizeMeasured) {\n        this.setState(function (prevState) {\n          var stateUpdate = _objectSpread({}, prevState, {\n            needToResetStyleCache: false\n          });\n\n          stateUpdate.instanceProps.scrollbarSize = getScrollbarSize();\n          stateUpdate.instanceProps.scrollbarSizeMeasured = true;\n          return stateUpdate;\n        });\n      }\n\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0 || typeof scrollTop === 'number' && scrollTop >= 0) {\n        var stateUpdate = Grid._getScrollToPositionStateUpdate({\n          prevState: this.state,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        });\n\n        if (stateUpdate) {\n          stateUpdate.needToResetStyleCache = false;\n          this.setState(stateUpdate);\n        }\n      } // refs don't work in `react-test-renderer`\n\n\n      if (this._scrollingContainer) {\n        // setting the ref's scrollLeft and scrollTop.\n        // Somehow in MultiGrid the main grid doesn't trigger a update on mount.\n        if (this._scrollingContainer.scrollLeft !== this.state.scrollLeft) {\n          this._scrollingContainer.scrollLeft = this.state.scrollLeft;\n        }\n\n        if (this._scrollingContainer.scrollTop !== this.state.scrollTop) {\n          this._scrollingContainer.scrollTop = this.state.scrollTop;\n        }\n      } // Don't update scroll offset if the size is 0; we don't render any cells in this case.\n      // Setting a state may cause us to later thing we've updated the offce when we haven't.\n\n\n      var sizeIsBiggerThanZero = height > 0 && width > 0;\n\n      if (scrollToColumn >= 0 && sizeIsBiggerThanZero) {\n        this._updateScrollLeftForScrollToColumn();\n      }\n\n      if (scrollToRow >= 0 && sizeIsBiggerThanZero) {\n        this._updateScrollTopForScrollToRow();\n      } // Update onRowsRendered callback\n\n\n      this._invokeOnGridRenderedHelper(); // Initialize onScroll callback\n\n\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft || 0,\n        scrollTop: scrollTop || 0,\n        totalColumnsWidth: instanceProps.columnSizeAndPositionManager.getTotalSize(),\n        totalRowsHeight: instanceProps.rowSizeAndPositionManager.getTotalSize()\n      });\n\n      this._maybeCallOnScrollbarPresenceChange();\n    }\n    /**\n     * @private\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) New scroll-to-cell props have been set\n     */\n\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this2 = this;\n\n      var _this$props5 = this.props,\n          autoHeight = _this$props5.autoHeight,\n          autoWidth = _this$props5.autoWidth,\n          columnCount = _this$props5.columnCount,\n          height = _this$props5.height,\n          rowCount = _this$props5.rowCount,\n          scrollToAlignment = _this$props5.scrollToAlignment,\n          scrollToColumn = _this$props5.scrollToColumn,\n          scrollToRow = _this$props5.scrollToRow,\n          width = _this$props5.width;\n      var _this$state = this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollPositionChangeReason = _this$state.scrollPositionChangeReason,\n          scrollTop = _this$state.scrollTop,\n          instanceProps = _this$state.instanceProps; // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.\n      // We must do this at the start of the method as we may calculate and update scroll position below.\n\n      this._handleInvalidatedGridSize(); // Handle edge case where column or row count has only just increased over 0.\n      // In this case we may have to restore a previously-specified scroll offset.\n      // For more info see bvaughn/react-virtualized/issues/218\n\n\n      var columnOrRowCountJustIncreasedFromZero = columnCount > 0 && prevProps.columnCount === 0 || rowCount > 0 && prevProps.rowCount === 0; // Make sure requested changes to :scrollLeft or :scrollTop get applied.\n      // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,\n      // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).\n      // So we only set these when we require an adjustment of the scroll position.\n      // See issue #2 for more information.\n\n      if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {\n        // @TRICKY :autoHeight and :autoWidth properties instructs Grid to leave :scrollTop and :scrollLeft management to an external HOC (eg WindowScroller).\n        // In this case we should avoid checking scrollingContainer.scrollTop and scrollingContainer.scrollLeft since it forces layout/flow.\n        if (!autoWidth && scrollLeft >= 0 && (scrollLeft !== this._scrollingContainer.scrollLeft || columnOrRowCountJustIncreasedFromZero)) {\n          this._scrollingContainer.scrollLeft = scrollLeft;\n        }\n\n        if (!autoHeight && scrollTop >= 0 && (scrollTop !== this._scrollingContainer.scrollTop || columnOrRowCountJustIncreasedFromZero)) {\n          this._scrollingContainer.scrollTop = scrollTop;\n        }\n      } // Special case where the previous size was 0:\n      // In this case we don't show any windowed cells at all.\n      // So we should always recalculate offset afterwards.\n\n\n      var sizeJustIncreasedFromZero = (prevProps.width === 0 || prevProps.height === 0) && height > 0 && width > 0; // Update scroll offsets if the current :scrollToColumn or :scrollToRow values requires it\n      // @TODO Do we also need this check or can the one in componentWillUpdate() suffice?\n\n      if (this._recomputeScrollLeftFlag) {\n        this._recomputeScrollLeftFlag = false;\n\n        this._updateScrollLeftForScrollToColumn(this.props);\n      } else {\n        updateScrollIndexHelper({\n          cellSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,\n          previousCellsCount: prevProps.columnCount,\n          previousCellSize: prevProps.columnWidth,\n          previousScrollToAlignment: prevProps.scrollToAlignment,\n          previousScrollToIndex: prevProps.scrollToColumn,\n          previousSize: prevProps.width,\n          scrollOffset: scrollLeft,\n          scrollToAlignment: scrollToAlignment,\n          scrollToIndex: scrollToColumn,\n          size: width,\n          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,\n          updateScrollIndexCallback: function updateScrollIndexCallback() {\n            return _this2._updateScrollLeftForScrollToColumn(_this2.props);\n          }\n        });\n      }\n\n      if (this._recomputeScrollTopFlag) {\n        this._recomputeScrollTopFlag = false;\n\n        this._updateScrollTopForScrollToRow(this.props);\n      } else {\n        updateScrollIndexHelper({\n          cellSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,\n          previousCellsCount: prevProps.rowCount,\n          previousCellSize: prevProps.rowHeight,\n          previousScrollToAlignment: prevProps.scrollToAlignment,\n          previousScrollToIndex: prevProps.scrollToRow,\n          previousSize: prevProps.height,\n          scrollOffset: scrollTop,\n          scrollToAlignment: scrollToAlignment,\n          scrollToIndex: scrollToRow,\n          size: height,\n          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,\n          updateScrollIndexCallback: function updateScrollIndexCallback() {\n            return _this2._updateScrollTopForScrollToRow(_this2.props);\n          }\n        });\n      } // Update onRowsRendered callback if start/stop indices have changed\n\n\n      this._invokeOnGridRenderedHelper(); // Changes to :scrollLeft or :scrollTop should also notify :onScroll listeners\n\n\n      if (scrollLeft !== prevState.scrollLeft || scrollTop !== prevState.scrollTop) {\n        var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n        var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n\n        this._invokeOnScrollMemoizer({\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          totalColumnsWidth: totalColumnsWidth,\n          totalRowsHeight: totalRowsHeight\n        });\n      }\n\n      this._maybeCallOnScrollbarPresenceChange();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this._disablePointerEventsTimeoutId) {\n        cancelAnimationTimeout(this._disablePointerEventsTimeoutId);\n      }\n    }\n    /**\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) Empty content (0 rows or columns)\n     * 2) New scroll props overriding the current state\n     * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props6 = this.props,\n          autoContainerWidth = _this$props6.autoContainerWidth,\n          autoHeight = _this$props6.autoHeight,\n          autoWidth = _this$props6.autoWidth,\n          className = _this$props6.className,\n          containerProps = _this$props6.containerProps,\n          containerRole = _this$props6.containerRole,\n          containerStyle = _this$props6.containerStyle,\n          height = _this$props6.height,\n          id = _this$props6.id,\n          noContentRenderer = _this$props6.noContentRenderer,\n          role = _this$props6.role,\n          style = _this$props6.style,\n          tabIndex = _this$props6.tabIndex,\n          width = _this$props6.width;\n      var _this$state2 = this.state,\n          instanceProps = _this$state2.instanceProps,\n          needToResetStyleCache = _this$state2.needToResetStyleCache;\n\n      var isScrolling = this._isScrolling();\n\n      var gridStyle = {\n        boxSizing: 'border-box',\n        direction: 'ltr',\n        height: autoHeight ? 'auto' : height,\n        position: 'relative',\n        width: autoWidth ? 'auto' : width,\n        WebkitOverflowScrolling: 'touch',\n        willChange: 'transform'\n      };\n\n      if (needToResetStyleCache) {\n        this._styleCache = {};\n      } // calculate _styleCache here\n      // if state.isScrolling (not from _isScrolling) then reset\n\n\n      if (!this.state.isScrolling) {\n        this._resetStyleCache();\n      } // calculate children to render here\n\n\n      this._calculateChildrenToRender(this.props, this.state);\n\n      var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n      var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize(); // Force browser to hide scrollbars when we know they aren't necessary.\n      // Otherwise once scrollbars appear they may not disappear again.\n      // For more info see issue #116\n\n      var verticalScrollBarSize = totalRowsHeight > height ? instanceProps.scrollbarSize : 0;\n      var horizontalScrollBarSize = totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;\n\n      if (horizontalScrollBarSize !== this._horizontalScrollBarSize || verticalScrollBarSize !== this._verticalScrollBarSize) {\n        this._horizontalScrollBarSize = horizontalScrollBarSize;\n        this._verticalScrollBarSize = verticalScrollBarSize;\n        this._scrollbarPresenceChanged = true;\n      } // Also explicitly init styles to 'auto' if scrollbars are required.\n      // This works around an obscure edge case where external CSS styles have not yet been loaded,\n      // But an initial scroll index of offset is set as an external prop.\n      // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.\n      // This was originally reported via clauderic/react-infinite-calendar/issues/23\n\n\n      gridStyle.overflowX = totalColumnsWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';\n      gridStyle.overflowY = totalRowsHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';\n      var childrenToDisplay = this._childrenToDisplay;\n      var showNoContentRenderer = childrenToDisplay.length === 0 && height > 0 && width > 0;\n      return React.createElement(\"div\", _extends({\n        ref: this._setScrollingContainerRef\n      }, containerProps, {\n        \"aria-label\": this.props['aria-label'],\n        \"aria-readonly\": this.props['aria-readonly'],\n        className: clsx('ReactVirtualized__Grid', className),\n        id: id,\n        onScroll: this._onScroll,\n        role: role,\n        style: _objectSpread({}, gridStyle, {}, style),\n        tabIndex: tabIndex\n      }), childrenToDisplay.length > 0 && React.createElement(\"div\", {\n        className: \"ReactVirtualized__Grid__innerScrollContainer\",\n        role: containerRole,\n        style: _objectSpread({\n          width: autoContainerWidth ? 'auto' : totalColumnsWidth,\n          height: totalRowsHeight,\n          maxWidth: totalColumnsWidth,\n          maxHeight: totalRowsHeight,\n          overflow: 'hidden',\n          pointerEvents: isScrolling ? 'none' : '',\n          position: 'relative'\n        }, containerStyle)\n      }, childrenToDisplay), showNoContentRenderer && noContentRenderer());\n    }\n    /* ---------------------------- Helper methods ---------------------------- */\n\n  }, {\n    key: \"_calculateChildrenToRender\",\n    value: function _calculateChildrenToRender() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      var cellRenderer = props.cellRenderer,\n          cellRangeRenderer = props.cellRangeRenderer,\n          columnCount = props.columnCount,\n          deferredMeasurementCache = props.deferredMeasurementCache,\n          height = props.height,\n          overscanColumnCount = props.overscanColumnCount,\n          overscanIndicesGetter = props.overscanIndicesGetter,\n          overscanRowCount = props.overscanRowCount,\n          rowCount = props.rowCount,\n          width = props.width,\n          isScrollingOptOut = props.isScrollingOptOut;\n      var scrollDirectionHorizontal = state.scrollDirectionHorizontal,\n          scrollDirectionVertical = state.scrollDirectionVertical,\n          instanceProps = state.instanceProps;\n      var scrollTop = this._initialScrollTop > 0 ? this._initialScrollTop : state.scrollTop;\n      var scrollLeft = this._initialScrollLeft > 0 ? this._initialScrollLeft : state.scrollLeft;\n\n      var isScrolling = this._isScrolling(props, state);\n\n      this._childrenToDisplay = []; // Render only enough columns and rows to cover the visible area of the grid.\n\n      if (height > 0 && width > 0) {\n        var visibleColumnIndices = instanceProps.columnSizeAndPositionManager.getVisibleCellRange({\n          containerSize: width,\n          offset: scrollLeft\n        });\n        var visibleRowIndices = instanceProps.rowSizeAndPositionManager.getVisibleCellRange({\n          containerSize: height,\n          offset: scrollTop\n        });\n        var horizontalOffsetAdjustment = instanceProps.columnSizeAndPositionManager.getOffsetAdjustment({\n          containerSize: width,\n          offset: scrollLeft\n        });\n        var verticalOffsetAdjustment = instanceProps.rowSizeAndPositionManager.getOffsetAdjustment({\n          containerSize: height,\n          offset: scrollTop\n        }); // Store for _invokeOnGridRenderedHelper()\n\n        this._renderedColumnStartIndex = visibleColumnIndices.start;\n        this._renderedColumnStopIndex = visibleColumnIndices.stop;\n        this._renderedRowStartIndex = visibleRowIndices.start;\n        this._renderedRowStopIndex = visibleRowIndices.stop;\n        var overscanColumnIndices = overscanIndicesGetter({\n          direction: 'horizontal',\n          cellCount: columnCount,\n          overscanCellsCount: overscanColumnCount,\n          scrollDirection: scrollDirectionHorizontal,\n          startIndex: typeof visibleColumnIndices.start === 'number' ? visibleColumnIndices.start : 0,\n          stopIndex: typeof visibleColumnIndices.stop === 'number' ? visibleColumnIndices.stop : -1\n        });\n        var overscanRowIndices = overscanIndicesGetter({\n          direction: 'vertical',\n          cellCount: rowCount,\n          overscanCellsCount: overscanRowCount,\n          scrollDirection: scrollDirectionVertical,\n          startIndex: typeof visibleRowIndices.start === 'number' ? visibleRowIndices.start : 0,\n          stopIndex: typeof visibleRowIndices.stop === 'number' ? visibleRowIndices.stop : -1\n        }); // Store for _invokeOnGridRenderedHelper()\n\n        var columnStartIndex = overscanColumnIndices.overscanStartIndex;\n        var columnStopIndex = overscanColumnIndices.overscanStopIndex;\n        var rowStartIndex = overscanRowIndices.overscanStartIndex;\n        var rowStopIndex = overscanRowIndices.overscanStopIndex; // Advanced use-cases (eg CellMeasurer) require batched measurements to determine accurate sizes.\n\n        if (deferredMeasurementCache) {\n          // If rows have a dynamic height, scan the rows we are about to render.\n          // If any have not yet been measured, then we need to render all columns initially,\n          // Because the height of the row is equal to the tallest cell within that row,\n          // (And so we can't know the height without measuring all column-cells first).\n          if (!deferredMeasurementCache.hasFixedHeight()) {\n            for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {\n              if (!deferredMeasurementCache.has(rowIndex, 0)) {\n                columnStartIndex = 0;\n                columnStopIndex = columnCount - 1;\n                break;\n              }\n            }\n          } // If columns have a dynamic width, scan the columns we are about to render.\n          // If any have not yet been measured, then we need to render all rows initially,\n          // Because the width of the column is equal to the widest cell within that column,\n          // (And so we can't know the width without measuring all row-cells first).\n\n\n          if (!deferredMeasurementCache.hasFixedWidth()) {\n            for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {\n              if (!deferredMeasurementCache.has(0, columnIndex)) {\n                rowStartIndex = 0;\n                rowStopIndex = rowCount - 1;\n                break;\n              }\n            }\n          }\n        }\n\n        this._childrenToDisplay = cellRangeRenderer({\n          cellCache: this._cellCache,\n          cellRenderer: cellRenderer,\n          columnSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,\n          columnStartIndex: columnStartIndex,\n          columnStopIndex: columnStopIndex,\n          deferredMeasurementCache: deferredMeasurementCache,\n          horizontalOffsetAdjustment: horizontalOffsetAdjustment,\n          isScrolling: isScrolling,\n          isScrollingOptOut: isScrollingOptOut,\n          parent: this,\n          rowSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,\n          rowStartIndex: rowStartIndex,\n          rowStopIndex: rowStopIndex,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          styleCache: this._styleCache,\n          verticalOffsetAdjustment: verticalOffsetAdjustment,\n          visibleColumnIndices: visibleColumnIndices,\n          visibleRowIndices: visibleRowIndices\n        }); // update the indices\n\n        this._columnStartIndex = columnStartIndex;\n        this._columnStopIndex = columnStopIndex;\n        this._rowStartIndex = rowStartIndex;\n        this._rowStopIndex = rowStopIndex;\n      }\n    }\n    /**\n     * Sets an :isScrolling flag for a small window of time.\n     * This flag is used to disable pointer events on the scrollable portion of the Grid.\n     * This prevents jerky/stuttery mouse-wheel scrolling.\n     */\n\n  }, {\n    key: \"_debounceScrollEnded\",\n    value: function _debounceScrollEnded() {\n      var scrollingResetTimeInterval = this.props.scrollingResetTimeInterval;\n\n      if (this._disablePointerEventsTimeoutId) {\n        cancelAnimationTimeout(this._disablePointerEventsTimeoutId);\n      }\n\n      this._disablePointerEventsTimeoutId = requestAnimationTimeout(this._debounceScrollEndedCallback, scrollingResetTimeInterval);\n    }\n  }, {\n    key: \"_handleInvalidatedGridSize\",\n\n    /**\n     * Check for batched CellMeasurer size invalidations.\n     * This will occur the first time one or more previously unmeasured cells are rendered.\n     */\n    value: function _handleInvalidatedGridSize() {\n      if (typeof this._deferredInvalidateColumnIndex === 'number' && typeof this._deferredInvalidateRowIndex === 'number') {\n        var columnIndex = this._deferredInvalidateColumnIndex;\n        var rowIndex = this._deferredInvalidateRowIndex;\n        this._deferredInvalidateColumnIndex = null;\n        this._deferredInvalidateRowIndex = null;\n        this.recomputeGridSize({\n          columnIndex: columnIndex,\n          rowIndex: rowIndex\n        });\n      }\n    }\n  }, {\n    key: \"_invokeOnScrollMemoizer\",\n    value: function _invokeOnScrollMemoizer(_ref6) {\n      var _this3 = this;\n\n      var scrollLeft = _ref6.scrollLeft,\n          scrollTop = _ref6.scrollTop,\n          totalColumnsWidth = _ref6.totalColumnsWidth,\n          totalRowsHeight = _ref6.totalRowsHeight;\n\n      this._onScrollMemoizer({\n        callback: function callback(_ref7) {\n          var scrollLeft = _ref7.scrollLeft,\n              scrollTop = _ref7.scrollTop;\n          var _this3$props = _this3.props,\n              height = _this3$props.height,\n              onScroll = _this3$props.onScroll,\n              width = _this3$props.width;\n          onScroll({\n            clientHeight: height,\n            clientWidth: width,\n            scrollHeight: totalRowsHeight,\n            scrollLeft: scrollLeft,\n            scrollTop: scrollTop,\n            scrollWidth: totalColumnsWidth\n          });\n        },\n        indices: {\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        }\n      });\n    }\n  }, {\n    key: \"_isScrolling\",\n    value: function _isScrolling() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      // If isScrolling is defined in props, use it to override the value in state\n      // This is a performance optimization for WindowScroller + Grid\n      return Object.hasOwnProperty.call(props, 'isScrolling') ? Boolean(props.isScrolling) : Boolean(state.isScrolling);\n    }\n  }, {\n    key: \"_maybeCallOnScrollbarPresenceChange\",\n    value: function _maybeCallOnScrollbarPresenceChange() {\n      if (this._scrollbarPresenceChanged) {\n        var onScrollbarPresenceChange = this.props.onScrollbarPresenceChange;\n        this._scrollbarPresenceChanged = false;\n        onScrollbarPresenceChange({\n          horizontal: this._horizontalScrollBarSize > 0,\n          size: this.state.instanceProps.scrollbarSize,\n          vertical: this._verticalScrollBarSize > 0\n        });\n      }\n    }\n  }, {\n    key: \"scrollToPosition\",\n\n    /**\n     * Scroll to the specified offset(s).\n     * Useful for animating position changes.\n     */\n    value: function scrollToPosition(_ref8) {\n      var scrollLeft = _ref8.scrollLeft,\n          scrollTop = _ref8.scrollTop;\n\n      var stateUpdate = Grid._getScrollToPositionStateUpdate({\n        prevState: this.state,\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop\n      });\n\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }, {\n    key: \"_getCalculatedScrollLeft\",\n    value: function _getCalculatedScrollLeft() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      return Grid._getCalculatedScrollLeft(props, state);\n    }\n  }, {\n    key: \"_updateScrollLeftForScrollToColumn\",\n    value: function _updateScrollLeftForScrollToColumn() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n      var stateUpdate = Grid._getScrollLeftForScrollToColumnStateUpdate(props, state);\n\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }, {\n    key: \"_getCalculatedScrollTop\",\n    value: function _getCalculatedScrollTop() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      return Grid._getCalculatedScrollTop(props, state);\n    }\n  }, {\n    key: \"_resetStyleCache\",\n    value: function _resetStyleCache() {\n      var styleCache = this._styleCache;\n      var cellCache = this._cellCache;\n      var isScrollingOptOut = this.props.isScrollingOptOut; // Reset cell and style caches once scrolling stops.\n      // This makes Grid simpler to use (since cells commonly change).\n      // And it keeps the caches from growing too large.\n      // Performance is most sensitive when a user is scrolling.\n      // Don't clear visible cells from cellCache if isScrollingOptOut is specified.\n      // This keeps the cellCache to a resonable size.\n\n      this._cellCache = {};\n      this._styleCache = {}; // Copy over the visible cell styles so avoid unnecessary re-render.\n\n      for (var rowIndex = this._rowStartIndex; rowIndex <= this._rowStopIndex; rowIndex++) {\n        for (var columnIndex = this._columnStartIndex; columnIndex <= this._columnStopIndex; columnIndex++) {\n          var key = \"\".concat(rowIndex, \"-\").concat(columnIndex);\n          this._styleCache[key] = styleCache[key];\n\n          if (isScrollingOptOut) {\n            this._cellCache[key] = cellCache[key];\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_updateScrollTopForScrollToRow\",\n    value: function _updateScrollTopForScrollToRow() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n      var stateUpdate = Grid._getScrollTopForScrollToRowStateUpdate(props, state);\n\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      var newState = {};\n\n      if (nextProps.columnCount === 0 && prevState.scrollLeft !== 0 || nextProps.rowCount === 0 && prevState.scrollTop !== 0) {\n        newState.scrollLeft = 0;\n        newState.scrollTop = 0; // only use scroll{Left,Top} from props if scrollTo{Column,Row} isn't specified\n        // scrollTo{Column,Row} should override scroll{Left,Top}\n      } else if (nextProps.scrollLeft !== prevState.scrollLeft && nextProps.scrollToColumn < 0 || nextProps.scrollTop !== prevState.scrollTop && nextProps.scrollToRow < 0) {\n        Object.assign(newState, Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: nextProps.scrollLeft,\n          scrollTop: nextProps.scrollTop\n        }));\n      }\n\n      var instanceProps = prevState.instanceProps; // Initially we should not clearStyleCache\n\n      newState.needToResetStyleCache = false;\n\n      if (nextProps.columnWidth !== instanceProps.prevColumnWidth || nextProps.rowHeight !== instanceProps.prevRowHeight) {\n        // Reset cache. set it to {} in render\n        newState.needToResetStyleCache = true;\n      }\n\n      instanceProps.columnSizeAndPositionManager.configure({\n        cellCount: nextProps.columnCount,\n        estimatedCellSize: Grid._getEstimatedColumnSize(nextProps),\n        cellSizeGetter: Grid._wrapSizeGetter(nextProps.columnWidth)\n      });\n      instanceProps.rowSizeAndPositionManager.configure({\n        cellCount: nextProps.rowCount,\n        estimatedCellSize: Grid._getEstimatedRowSize(nextProps),\n        cellSizeGetter: Grid._wrapSizeGetter(nextProps.rowHeight)\n      });\n\n      if (instanceProps.prevColumnCount === 0 || instanceProps.prevRowCount === 0) {\n        instanceProps.prevColumnCount = 0;\n        instanceProps.prevRowCount = 0;\n      } // If scrolling is controlled outside this component, clear cache when scrolling stops\n\n\n      if (nextProps.autoHeight && nextProps.isScrolling === false && instanceProps.prevIsScrolling === true) {\n        Object.assign(newState, {\n          isScrolling: false\n        });\n      }\n\n      var maybeStateA;\n      var maybeStateB;\n      calculateSizeAndPositionDataAndUpdateScrollOffset({\n        cellCount: instanceProps.prevColumnCount,\n        cellSize: typeof instanceProps.prevColumnWidth === 'number' ? instanceProps.prevColumnWidth : null,\n        computeMetadataCallback: function computeMetadataCallback() {\n          return instanceProps.columnSizeAndPositionManager.resetCell(0);\n        },\n        computeMetadataCallbackProps: nextProps,\n        nextCellsCount: nextProps.columnCount,\n        nextCellSize: typeof nextProps.columnWidth === 'number' ? nextProps.columnWidth : null,\n        nextScrollToIndex: nextProps.scrollToColumn,\n        scrollToIndex: instanceProps.prevScrollToColumn,\n        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {\n          maybeStateA = Grid._getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState);\n        }\n      });\n      calculateSizeAndPositionDataAndUpdateScrollOffset({\n        cellCount: instanceProps.prevRowCount,\n        cellSize: typeof instanceProps.prevRowHeight === 'number' ? instanceProps.prevRowHeight : null,\n        computeMetadataCallback: function computeMetadataCallback() {\n          return instanceProps.rowSizeAndPositionManager.resetCell(0);\n        },\n        computeMetadataCallbackProps: nextProps,\n        nextCellsCount: nextProps.rowCount,\n        nextCellSize: typeof nextProps.rowHeight === 'number' ? nextProps.rowHeight : null,\n        nextScrollToIndex: nextProps.scrollToRow,\n        scrollToIndex: instanceProps.prevScrollToRow,\n        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {\n          maybeStateB = Grid._getScrollTopForScrollToRowStateUpdate(nextProps, prevState);\n        }\n      });\n      instanceProps.prevColumnCount = nextProps.columnCount;\n      instanceProps.prevColumnWidth = nextProps.columnWidth;\n      instanceProps.prevIsScrolling = nextProps.isScrolling === true;\n      instanceProps.prevRowCount = nextProps.rowCount;\n      instanceProps.prevRowHeight = nextProps.rowHeight;\n      instanceProps.prevScrollToColumn = nextProps.scrollToColumn;\n      instanceProps.prevScrollToRow = nextProps.scrollToRow; // getting scrollBarSize (moved from componentWillMount)\n\n      instanceProps.scrollbarSize = nextProps.getScrollbarSize();\n\n      if (instanceProps.scrollbarSize === undefined) {\n        instanceProps.scrollbarSizeMeasured = false;\n        instanceProps.scrollbarSize = 0;\n      } else {\n        instanceProps.scrollbarSizeMeasured = true;\n      }\n\n      newState.instanceProps = instanceProps;\n      return _objectSpread({}, newState, {}, maybeStateA, {}, maybeStateB);\n    }\n  }, {\n    key: \"_getEstimatedColumnSize\",\n    value: function _getEstimatedColumnSize(props) {\n      return typeof props.columnWidth === 'number' ? props.columnWidth : props.estimatedColumnSize;\n    }\n  }, {\n    key: \"_getEstimatedRowSize\",\n    value: function _getEstimatedRowSize(props) {\n      return typeof props.rowHeight === 'number' ? props.rowHeight : props.estimatedRowSize;\n    }\n  }, {\n    key: \"_getScrollToPositionStateUpdate\",\n\n    /**\n     * Get the updated state after scrolling to\n     * scrollLeft and scrollTop\n     */\n    value: function _getScrollToPositionStateUpdate(_ref9) {\n      var prevState = _ref9.prevState,\n          scrollLeft = _ref9.scrollLeft,\n          scrollTop = _ref9.scrollTop;\n      var newState = {\n        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\n      };\n\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0) {\n        newState.scrollDirectionHorizontal = scrollLeft > prevState.scrollLeft ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD;\n        newState.scrollLeft = scrollLeft;\n      }\n\n      if (typeof scrollTop === 'number' && scrollTop >= 0) {\n        newState.scrollDirectionVertical = scrollTop > prevState.scrollTop ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD;\n        newState.scrollTop = scrollTop;\n      }\n\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft || typeof scrollTop === 'number' && scrollTop >= 0 && scrollTop !== prevState.scrollTop) {\n        return newState;\n      }\n\n      return {};\n    }\n  }, {\n    key: \"_wrapSizeGetter\",\n    value: function _wrapSizeGetter(value) {\n      return typeof value === 'function' ? value : function () {\n        return value;\n      };\n    }\n  }, {\n    key: \"_getCalculatedScrollLeft\",\n    value: function _getCalculatedScrollLeft(nextProps, prevState) {\n      var columnCount = nextProps.columnCount,\n          height = nextProps.height,\n          scrollToAlignment = nextProps.scrollToAlignment,\n          scrollToColumn = nextProps.scrollToColumn,\n          width = nextProps.width;\n      var scrollLeft = prevState.scrollLeft,\n          instanceProps = prevState.instanceProps;\n\n      if (columnCount > 0) {\n        var finalColumn = columnCount - 1;\n        var targetIndex = scrollToColumn < 0 ? finalColumn : Math.min(finalColumn, scrollToColumn);\n        var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n        var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalRowsHeight > height ? instanceProps.scrollbarSize : 0;\n        return instanceProps.columnSizeAndPositionManager.getUpdatedOffsetForIndex({\n          align: scrollToAlignment,\n          containerSize: width - scrollBarSize,\n          currentOffset: scrollLeft,\n          targetIndex: targetIndex\n        });\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"_getScrollLeftForScrollToColumnStateUpdate\",\n    value: function _getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState) {\n      var scrollLeft = prevState.scrollLeft;\n\n      var calculatedScrollLeft = Grid._getCalculatedScrollLeft(nextProps, prevState);\n\n      if (typeof calculatedScrollLeft === 'number' && calculatedScrollLeft >= 0 && scrollLeft !== calculatedScrollLeft) {\n        return Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: calculatedScrollLeft,\n          scrollTop: -1\n        });\n      }\n\n      return {};\n    }\n  }, {\n    key: \"_getCalculatedScrollTop\",\n    value: function _getCalculatedScrollTop(nextProps, prevState) {\n      var height = nextProps.height,\n          rowCount = nextProps.rowCount,\n          scrollToAlignment = nextProps.scrollToAlignment,\n          scrollToRow = nextProps.scrollToRow,\n          width = nextProps.width;\n      var scrollTop = prevState.scrollTop,\n          instanceProps = prevState.instanceProps;\n\n      if (rowCount > 0) {\n        var finalRow = rowCount - 1;\n        var targetIndex = scrollToRow < 0 ? finalRow : Math.min(finalRow, scrollToRow);\n        var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n        var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;\n        return instanceProps.rowSizeAndPositionManager.getUpdatedOffsetForIndex({\n          align: scrollToAlignment,\n          containerSize: height - scrollBarSize,\n          currentOffset: scrollTop,\n          targetIndex: targetIndex\n        });\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"_getScrollTopForScrollToRowStateUpdate\",\n    value: function _getScrollTopForScrollToRowStateUpdate(nextProps, prevState) {\n      var scrollTop = prevState.scrollTop;\n\n      var calculatedScrollTop = Grid._getCalculatedScrollTop(nextProps, prevState);\n\n      if (typeof calculatedScrollTop === 'number' && calculatedScrollTop >= 0 && scrollTop !== calculatedScrollTop) {\n        return Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: -1,\n          scrollTop: calculatedScrollTop\n        });\n      }\n\n      return {};\n    }\n  }]);\n\n  return Grid;\n}(React.PureComponent), _defineProperty(_class, \"propTypes\", process.env.NODE_ENV === 'production' ? null : {\n  \"aria-label\": PropTypes.string.isRequired,\n  \"aria-readonly\": PropTypes.bool,\n\n  /**\n   * Set the width of the inner scrollable container to 'auto'.\n   * This is useful for single-column Grids to ensure that the column doesn't extend below a vertical scrollbar.\n   */\n  \"autoContainerWidth\": PropTypes.bool.isRequired,\n\n  /**\n   * Removes fixed height from the scrollingContainer so that the total height of rows can stretch the window.\n   * Intended for use with WindowScroller\n   */\n  \"autoHeight\": PropTypes.bool.isRequired,\n\n  /**\n   * Removes fixed width from the scrollingContainer so that the total width of rows can stretch the window.\n   * Intended for use with WindowScroller\n   */\n  \"autoWidth\": PropTypes.bool.isRequired,\n\n  /** Responsible for rendering a cell given an row and column index.  */\n  \"cellRenderer\": function cellRenderer() {\n    return (typeof bpfrpt_proptype_CellRenderer === \"function\" ? bpfrpt_proptype_CellRenderer.isRequired ? bpfrpt_proptype_CellRenderer.isRequired : bpfrpt_proptype_CellRenderer : PropTypes.shape(bpfrpt_proptype_CellRenderer).isRequired).apply(this, arguments);\n  },\n\n  /** Responsible for rendering a group of cells given their index ranges.  */\n  \"cellRangeRenderer\": function cellRangeRenderer() {\n    return (typeof bpfrpt_proptype_CellRangeRenderer === \"function\" ? bpfrpt_proptype_CellRangeRenderer.isRequired ? bpfrpt_proptype_CellRangeRenderer.isRequired : bpfrpt_proptype_CellRangeRenderer : PropTypes.shape(bpfrpt_proptype_CellRangeRenderer).isRequired).apply(this, arguments);\n  },\n\n  /** Optional custom CSS class name to attach to root Grid element.  */\n  \"className\": PropTypes.string,\n\n  /** Number of columns in grid.  */\n  \"columnCount\": PropTypes.number.isRequired,\n\n  /** Either a fixed column width (number) or a function that returns the width of a column given its index.  */\n  \"columnWidth\": function columnWidth() {\n    return (typeof bpfrpt_proptype_CellSize === \"function\" ? bpfrpt_proptype_CellSize.isRequired ? bpfrpt_proptype_CellSize.isRequired : bpfrpt_proptype_CellSize : PropTypes.shape(bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);\n  },\n\n  /** Unfiltered props for the Grid container. */\n  \"containerProps\": PropTypes.object,\n\n  /** ARIA role for the cell-container.  */\n  \"containerRole\": PropTypes.string.isRequired,\n\n  /** Optional inline style applied to inner cell-container */\n  \"containerStyle\": PropTypes.object.isRequired,\n\n  /**\n   * If CellMeasurer is used to measure this Grid's children, this should be a pointer to its CellMeasurerCache.\n   * A shared CellMeasurerCache reference enables Grid and CellMeasurer to share measurement data.\n   */\n  \"deferredMeasurementCache\": PropTypes.object,\n\n  /**\n   * Used to estimate the total width of a Grid before all of its columns have actually been measured.\n   * The estimated total width is adjusted as columns are rendered.\n   */\n  \"estimatedColumnSize\": PropTypes.number.isRequired,\n\n  /**\n   * Used to estimate the total height of a Grid before all of its rows have actually been measured.\n   * The estimated total height is adjusted as rows are rendered.\n   */\n  \"estimatedRowSize\": PropTypes.number.isRequired,\n\n  /** Exposed for testing purposes only.  */\n  \"getScrollbarSize\": PropTypes.func.isRequired,\n\n  /** Height of Grid; this property determines the number of visible (vs virtualized) rows.  */\n  \"height\": PropTypes.number.isRequired,\n\n  /** Optional custom id to attach to root Grid element.  */\n  \"id\": PropTypes.string,\n\n  /**\n   * Override internal is-scrolling state tracking.\n   * This property is primarily intended for use with the WindowScroller component.\n   */\n  \"isScrolling\": PropTypes.bool,\n\n  /**\n   * Opt-out of isScrolling param passed to cellRangeRenderer.\n   * To avoid the extra render when scroll stops.\n   */\n  \"isScrollingOptOut\": PropTypes.bool.isRequired,\n\n  /** Optional renderer to be used in place of rows when either :rowCount or :columnCount is 0.  */\n  \"noContentRenderer\": function noContentRenderer() {\n    return (typeof bpfrpt_proptype_NoContentRenderer === \"function\" ? bpfrpt_proptype_NoContentRenderer.isRequired ? bpfrpt_proptype_NoContentRenderer.isRequired : bpfrpt_proptype_NoContentRenderer : PropTypes.shape(bpfrpt_proptype_NoContentRenderer).isRequired).apply(this, arguments);\n  },\n\n  /**\n   * Callback invoked whenever the scroll offset changes within the inner scrollable region.\n   * This callback can be used to sync scrolling between lists, tables, or grids.\n   */\n  \"onScroll\": PropTypes.func.isRequired,\n\n  /**\n   * Called whenever a horizontal or vertical scrollbar is added or removed.\n   * This prop is not intended for end-user use;\n   * It is used by MultiGrid to support fixed-row/fixed-column scroll syncing.\n   */\n  \"onScrollbarPresenceChange\": PropTypes.func.isRequired,\n\n  /** Callback invoked with information about the section of the Grid that was just rendered.  */\n  \"onSectionRendered\": PropTypes.func.isRequired,\n\n  /**\n   * Number of columns to render before/after the visible section of the grid.\n   * These columns can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.\n   */\n  \"overscanColumnCount\": PropTypes.number.isRequired,\n\n  /**\n   * Calculates the number of cells to overscan before and after a specified range.\n   * This function ensures that overscanning doesn't exceed the available cells.\n   */\n  \"overscanIndicesGetter\": function overscanIndicesGetter() {\n    return (typeof bpfrpt_proptype_OverscanIndicesGetter === \"function\" ? bpfrpt_proptype_OverscanIndicesGetter.isRequired ? bpfrpt_proptype_OverscanIndicesGetter.isRequired : bpfrpt_proptype_OverscanIndicesGetter : PropTypes.shape(bpfrpt_proptype_OverscanIndicesGetter).isRequired).apply(this, arguments);\n  },\n\n  /**\n   * Number of rows to render above/below the visible section of the grid.\n   * These rows can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.\n   */\n  \"overscanRowCount\": PropTypes.number.isRequired,\n\n  /** ARIA role for the grid element.  */\n  \"role\": PropTypes.string.isRequired,\n\n  /**\n   * Either a fixed row height (number) or a function that returns the height of a row given its index.\n   * Should implement the following interface: ({ index: number }): number\n   */\n  \"rowHeight\": function rowHeight() {\n    return (typeof bpfrpt_proptype_CellSize === \"function\" ? bpfrpt_proptype_CellSize.isRequired ? bpfrpt_proptype_CellSize.isRequired : bpfrpt_proptype_CellSize : PropTypes.shape(bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);\n  },\n\n  /** Number of rows in grid.  */\n  \"rowCount\": PropTypes.number.isRequired,\n\n  /** Wait this amount of time after the last scroll event before resetting Grid `pointer-events`. */\n  \"scrollingResetTimeInterval\": PropTypes.number.isRequired,\n\n  /** Horizontal offset. */\n  \"scrollLeft\": PropTypes.number,\n\n  /**\n   * Controls scroll-to-cell behavior of the Grid.\n   * The default (\"auto\") scrolls the least amount possible to ensure that the specified cell is fully visible.\n   * Use \"start\" to align cells to the top/left of the Grid and \"end\" to align bottom/right.\n   */\n  \"scrollToAlignment\": function scrollToAlignment() {\n    return (typeof bpfrpt_proptype_Alignment === \"function\" ? bpfrpt_proptype_Alignment.isRequired ? bpfrpt_proptype_Alignment.isRequired : bpfrpt_proptype_Alignment : PropTypes.shape(bpfrpt_proptype_Alignment).isRequired).apply(this, arguments);\n  },\n\n  /** Column index to ensure visible (by forcefully scrolling if necessary) */\n  \"scrollToColumn\": PropTypes.number.isRequired,\n\n  /** Vertical offset. */\n  \"scrollTop\": PropTypes.number,\n\n  /** Row index to ensure visible (by forcefully scrolling if necessary) */\n  \"scrollToRow\": PropTypes.number.isRequired,\n\n  /** Optional inline style */\n  \"style\": PropTypes.object.isRequired,\n\n  /** Tab index for focus */\n  \"tabIndex\": PropTypes.number,\n\n  /** Width of Grid; this property determines the number of visible (vs virtualized) columns.  */\n  \"width\": PropTypes.number.isRequired\n}), _temp);\n\n_defineProperty(Grid, \"defaultProps\", {\n  'aria-label': 'grid',\n  'aria-readonly': true,\n  autoContainerWidth: false,\n  autoHeight: false,\n  autoWidth: false,\n  cellRangeRenderer: defaultCellRangeRenderer,\n  containerRole: 'rowgroup',\n  containerStyle: {},\n  estimatedColumnSize: 100,\n  estimatedRowSize: 30,\n  getScrollbarSize: scrollbarSize,\n  noContentRenderer: renderNull,\n  onScroll: function onScroll() {},\n  onScrollbarPresenceChange: function onScrollbarPresenceChange() {},\n  onSectionRendered: function onSectionRendered() {},\n  overscanColumnCount: 0,\n  overscanIndicesGetter: defaultOverscanIndicesGetter,\n  overscanRowCount: 10,\n  role: 'grid',\n  scrollingResetTimeInterval: DEFAULT_SCROLLING_RESET_TIME_INTERVAL,\n  scrollToAlignment: 'auto',\n  scrollToColumn: -1,\n  scrollToRow: -1,\n  style: {},\n  tabIndex: 0,\n  isScrollingOptOut: false\n});\n\npolyfill(Grid);\nexport default Grid;\nimport { bpfrpt_proptype_CellRenderer } from \"./types\";\nimport { bpfrpt_proptype_CellRangeRenderer } from \"./types\";\nimport { bpfrpt_proptype_CellPosition } from \"./types\";\nimport { bpfrpt_proptype_CellSize } from \"./types\";\nimport { bpfrpt_proptype_CellSizeGetter } from \"./types\";\nimport { bpfrpt_proptype_NoContentRenderer } from \"./types\";\nimport { bpfrpt_proptype_Scroll } from \"./types\";\nimport { bpfrpt_proptype_ScrollbarPresenceChange } from \"./types\";\nimport { bpfrpt_proptype_RenderedSection } from \"./types\";\nimport { bpfrpt_proptype_OverscanIndicesGetter } from \"./types\";\nimport { bpfrpt_proptype_Alignment } from \"./types\";\nimport { bpfrpt_proptype_CellCache } from \"./types\";\nimport { bpfrpt_proptype_StyleCache } from \"./types\";\nimport { bpfrpt_proptype_AnimationTimeoutId } from \"../utils/requestAnimationTimeout\";\nimport PropTypes from \"prop-types\";"],"mappings":"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"},"metadata":{},"sourceType":"module"}