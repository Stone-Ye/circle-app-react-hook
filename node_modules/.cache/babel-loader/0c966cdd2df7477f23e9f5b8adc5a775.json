{"ast":null,"code":"/**\n * Gets the dimensions of the element, accounting for API differences between\n * `window` and other DOM elements.\n */\n// TODO Move this into WindowScroller and import from there\nvar isWindow = function isWindow(element) {\n  return element === window;\n};\n\nvar getBoundingBox = function getBoundingBox(element) {\n  return element.getBoundingClientRect();\n};\n\nexport function getDimensions(scrollElement, props) {\n  if (!scrollElement) {\n    return {\n      height: props.serverHeight,\n      width: props.serverWidth\n    };\n  } else if (isWindow(scrollElement)) {\n    var _window = window,\n        innerHeight = _window.innerHeight,\n        innerWidth = _window.innerWidth;\n    return {\n      height: typeof innerHeight === 'number' ? innerHeight : 0,\n      width: typeof innerWidth === 'number' ? innerWidth : 0\n    };\n  } else {\n    return getBoundingBox(scrollElement);\n  }\n}\n/**\n * Gets the vertical and horizontal position of an element within its scroll container.\n * Elements that have been “scrolled past” return negative values.\n * Handles edge-case where a user is navigating back (history) from an already-scrolled page.\n * In this case the body’s top or left position will be a negative number and this element’s top or left will be increased (by that amount).\n */\n\nexport function getPositionOffset(element, container) {\n  if (isWindow(container) && document.documentElement) {\n    var containerElement = document.documentElement;\n    var elementRect = getBoundingBox(element);\n    var containerRect = getBoundingBox(containerElement);\n    return {\n      top: elementRect.top - containerRect.top,\n      left: elementRect.left - containerRect.left\n    };\n  } else {\n    var scrollOffset = getScrollOffset(container);\n\n    var _elementRect = getBoundingBox(element);\n\n    var _containerRect = getBoundingBox(container);\n\n    return {\n      top: _elementRect.top + scrollOffset.top - _containerRect.top,\n      left: _elementRect.left + scrollOffset.left - _containerRect.left\n    };\n  }\n}\n/**\n * Gets the vertical and horizontal scroll amount of the element, accounting for IE compatibility\n * and API differences between `window` and other DOM elements.\n */\n\nexport function getScrollOffset(element) {\n  if (isWindow(element) && document.documentElement) {\n    return {\n      top: 'scrollY' in window ? window.scrollY : document.documentElement.scrollTop,\n      left: 'scrollX' in window ? window.scrollX : document.documentElement.scrollLeft\n    };\n  } else {\n    return {\n      top: element.scrollTop,\n      left: element.scrollLeft\n    };\n  }\n}","map":{"version":3,"names":["isWindow","element","window","getBoundingBox","getBoundingClientRect","getDimensions","scrollElement","props","height","serverHeight","width","serverWidth","_window","innerHeight","innerWidth","getPositionOffset","container","document","documentElement","containerElement","elementRect","containerRect","top","left","scrollOffset","getScrollOffset","_elementRect","_containerRect","scrollY","scrollTop","scrollX","scrollLeft"],"sources":["/Users/stoneye/react_project/circle-app-react-hook/node_modules/react-virtualized/dist/es/WindowScroller/utils/dimensions.js"],"sourcesContent":["/**\n * Gets the dimensions of the element, accounting for API differences between\n * `window` and other DOM elements.\n */\n// TODO Move this into WindowScroller and import from there\nvar isWindow = function isWindow(element) {\n  return element === window;\n};\n\nvar getBoundingBox = function getBoundingBox(element) {\n  return element.getBoundingClientRect();\n};\n\nexport function getDimensions(scrollElement, props) {\n  if (!scrollElement) {\n    return {\n      height: props.serverHeight,\n      width: props.serverWidth\n    };\n  } else if (isWindow(scrollElement)) {\n    var _window = window,\n        innerHeight = _window.innerHeight,\n        innerWidth = _window.innerWidth;\n    return {\n      height: typeof innerHeight === 'number' ? innerHeight : 0,\n      width: typeof innerWidth === 'number' ? innerWidth : 0\n    };\n  } else {\n    return getBoundingBox(scrollElement);\n  }\n}\n/**\n * Gets the vertical and horizontal position of an element within its scroll container.\n * Elements that have been “scrolled past” return negative values.\n * Handles edge-case where a user is navigating back (history) from an already-scrolled page.\n * In this case the body’s top or left position will be a negative number and this element’s top or left will be increased (by that amount).\n */\n\nexport function getPositionOffset(element, container) {\n  if (isWindow(container) && document.documentElement) {\n    var containerElement = document.documentElement;\n    var elementRect = getBoundingBox(element);\n    var containerRect = getBoundingBox(containerElement);\n    return {\n      top: elementRect.top - containerRect.top,\n      left: elementRect.left - containerRect.left\n    };\n  } else {\n    var scrollOffset = getScrollOffset(container);\n\n    var _elementRect = getBoundingBox(element);\n\n    var _containerRect = getBoundingBox(container);\n\n    return {\n      top: _elementRect.top + scrollOffset.top - _containerRect.top,\n      left: _elementRect.left + scrollOffset.left - _containerRect.left\n    };\n  }\n}\n/**\n * Gets the vertical and horizontal scroll amount of the element, accounting for IE compatibility\n * and API differences between `window` and other DOM elements.\n */\n\nexport function getScrollOffset(element) {\n  if (isWindow(element) && document.documentElement) {\n    return {\n      top: 'scrollY' in window ? window.scrollY : document.documentElement.scrollTop,\n      left: 'scrollX' in window ? window.scrollX : document.documentElement.scrollLeft\n    };\n  } else {\n    return {\n      top: element.scrollTop,\n      left: element.scrollLeft\n    };\n  }\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,IAAIA,QAAQ,GAAG,SAASA,QAAT,CAAkBC,OAAlB,EAA2B;EACxC,OAAOA,OAAO,KAAKC,MAAnB;AACD,CAFD;;AAIA,IAAIC,cAAc,GAAG,SAASA,cAAT,CAAwBF,OAAxB,EAAiC;EACpD,OAAOA,OAAO,CAACG,qBAAR,EAAP;AACD,CAFD;;AAIA,OAAO,SAASC,aAAT,CAAuBC,aAAvB,EAAsCC,KAAtC,EAA6C;EAClD,IAAI,CAACD,aAAL,EAAoB;IAClB,OAAO;MACLE,MAAM,EAAED,KAAK,CAACE,YADT;MAELC,KAAK,EAAEH,KAAK,CAACI;IAFR,CAAP;EAID,CALD,MAKO,IAAIX,QAAQ,CAACM,aAAD,CAAZ,EAA6B;IAClC,IAAIM,OAAO,GAAGV,MAAd;IAAA,IACIW,WAAW,GAAGD,OAAO,CAACC,WAD1B;IAAA,IAEIC,UAAU,GAAGF,OAAO,CAACE,UAFzB;IAGA,OAAO;MACLN,MAAM,EAAE,OAAOK,WAAP,KAAuB,QAAvB,GAAkCA,WAAlC,GAAgD,CADnD;MAELH,KAAK,EAAE,OAAOI,UAAP,KAAsB,QAAtB,GAAiCA,UAAjC,GAA8C;IAFhD,CAAP;EAID,CARM,MAQA;IACL,OAAOX,cAAc,CAACG,aAAD,CAArB;EACD;AACF;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASS,iBAAT,CAA2Bd,OAA3B,EAAoCe,SAApC,EAA+C;EACpD,IAAIhB,QAAQ,CAACgB,SAAD,CAAR,IAAuBC,QAAQ,CAACC,eAApC,EAAqD;IACnD,IAAIC,gBAAgB,GAAGF,QAAQ,CAACC,eAAhC;IACA,IAAIE,WAAW,GAAGjB,cAAc,CAACF,OAAD,CAAhC;IACA,IAAIoB,aAAa,GAAGlB,cAAc,CAACgB,gBAAD,CAAlC;IACA,OAAO;MACLG,GAAG,EAAEF,WAAW,CAACE,GAAZ,GAAkBD,aAAa,CAACC,GADhC;MAELC,IAAI,EAAEH,WAAW,CAACG,IAAZ,GAAmBF,aAAa,CAACE;IAFlC,CAAP;EAID,CARD,MAQO;IACL,IAAIC,YAAY,GAAGC,eAAe,CAACT,SAAD,CAAlC;;IAEA,IAAIU,YAAY,GAAGvB,cAAc,CAACF,OAAD,CAAjC;;IAEA,IAAI0B,cAAc,GAAGxB,cAAc,CAACa,SAAD,CAAnC;;IAEA,OAAO;MACLM,GAAG,EAAEI,YAAY,CAACJ,GAAb,GAAmBE,YAAY,CAACF,GAAhC,GAAsCK,cAAc,CAACL,GADrD;MAELC,IAAI,EAAEG,YAAY,CAACH,IAAb,GAAoBC,YAAY,CAACD,IAAjC,GAAwCI,cAAc,CAACJ;IAFxD,CAAP;EAID;AACF;AACD;AACA;AACA;AACA;;AAEA,OAAO,SAASE,eAAT,CAAyBxB,OAAzB,EAAkC;EACvC,IAAID,QAAQ,CAACC,OAAD,CAAR,IAAqBgB,QAAQ,CAACC,eAAlC,EAAmD;IACjD,OAAO;MACLI,GAAG,EAAE,aAAapB,MAAb,GAAsBA,MAAM,CAAC0B,OAA7B,GAAuCX,QAAQ,CAACC,eAAT,CAAyBW,SADhE;MAELN,IAAI,EAAE,aAAarB,MAAb,GAAsBA,MAAM,CAAC4B,OAA7B,GAAuCb,QAAQ,CAACC,eAAT,CAAyBa;IAFjE,CAAP;EAID,CALD,MAKO;IACL,OAAO;MACLT,GAAG,EAAErB,OAAO,CAAC4B,SADR;MAELN,IAAI,EAAEtB,OAAO,CAAC8B;IAFT,CAAP;EAID;AACF"},"metadata":{},"sourceType":"module"}