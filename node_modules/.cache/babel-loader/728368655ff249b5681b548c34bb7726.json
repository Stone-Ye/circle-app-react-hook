{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport PropTypes from 'prop-types';\nimport * as React from 'react';\nimport CollectionView from './CollectionView';\nimport _calculateSizeAndPositionData from './utils/calculateSizeAndPositionData';\nimport getUpdatedOffsetForIndex from '../utils/getUpdatedOffsetForIndex';\n/**\n * Renders scattered or non-linear data.\n * Unlike Grid, which renders checkerboard data, Collection can render arbitrarily positioned- even overlapping- data.\n */\n\nvar Collection = /*#__PURE__*/function (_React$PureComponent) {\n  _inherits(Collection, _React$PureComponent);\n\n  function Collection(props, context) {\n    var _this;\n\n    _classCallCheck(this, Collection);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Collection).call(this, props, context));\n    _this._cellMetadata = [];\n    _this._lastRenderedCellIndices = []; // Cell cache during scroll (for performance)\n\n    _this._cellCache = [];\n    _this._isScrollingChange = _this._isScrollingChange.bind(_assertThisInitialized(_this));\n    _this._setCollectionViewRef = _this._setCollectionViewRef.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(Collection, [{\n    key: \"forceUpdate\",\n    value: function forceUpdate() {\n      if (this._collectionView !== undefined) {\n        this._collectionView.forceUpdate();\n      }\n    }\n    /** See Collection#recomputeCellSizesAndPositions */\n\n  }, {\n    key: \"recomputeCellSizesAndPositions\",\n    value: function recomputeCellSizesAndPositions() {\n      this._cellCache = [];\n\n      this._collectionView.recomputeCellSizesAndPositions();\n    }\n    /** React lifecycle methods */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var props = _extends({}, this.props);\n\n      return React.createElement(CollectionView, _extends({\n        cellLayoutManager: this,\n        isScrollingChange: this._isScrollingChange,\n        ref: this._setCollectionViewRef\n      }, props));\n    }\n    /** CellLayoutManager interface */\n\n  }, {\n    key: \"calculateSizeAndPositionData\",\n    value: function calculateSizeAndPositionData() {\n      var _this$props = this.props,\n          cellCount = _this$props.cellCount,\n          cellSizeAndPositionGetter = _this$props.cellSizeAndPositionGetter,\n          sectionSize = _this$props.sectionSize;\n\n      var data = _calculateSizeAndPositionData({\n        cellCount: cellCount,\n        cellSizeAndPositionGetter: cellSizeAndPositionGetter,\n        sectionSize: sectionSize\n      });\n\n      this._cellMetadata = data.cellMetadata;\n      this._sectionManager = data.sectionManager;\n      this._height = data.height;\n      this._width = data.width;\n    }\n    /**\n     * Returns the most recently rendered set of cell indices.\n     */\n\n  }, {\n    key: \"getLastRenderedIndices\",\n    value: function getLastRenderedIndices() {\n      return this._lastRenderedCellIndices;\n    }\n    /**\n     * Calculates the minimum amount of change from the current scroll position to ensure the specified cell is (fully) visible.\n     */\n\n  }, {\n    key: \"getScrollPositionForCell\",\n    value: function getScrollPositionForCell(_ref) {\n      var align = _ref.align,\n          cellIndex = _ref.cellIndex,\n          height = _ref.height,\n          scrollLeft = _ref.scrollLeft,\n          scrollTop = _ref.scrollTop,\n          width = _ref.width;\n      var cellCount = this.props.cellCount;\n\n      if (cellIndex >= 0 && cellIndex < cellCount) {\n        var cellMetadata = this._cellMetadata[cellIndex];\n        scrollLeft = getUpdatedOffsetForIndex({\n          align: align,\n          cellOffset: cellMetadata.x,\n          cellSize: cellMetadata.width,\n          containerSize: width,\n          currentOffset: scrollLeft,\n          targetIndex: cellIndex\n        });\n        scrollTop = getUpdatedOffsetForIndex({\n          align: align,\n          cellOffset: cellMetadata.y,\n          cellSize: cellMetadata.height,\n          containerSize: height,\n          currentOffset: scrollTop,\n          targetIndex: cellIndex\n        });\n      }\n\n      return {\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop\n      };\n    }\n  }, {\n    key: \"getTotalSize\",\n    value: function getTotalSize() {\n      return {\n        height: this._height,\n        width: this._width\n      };\n    }\n  }, {\n    key: \"cellRenderers\",\n    value: function cellRenderers(_ref2) {\n      var _this2 = this;\n\n      var height = _ref2.height,\n          isScrolling = _ref2.isScrolling,\n          width = _ref2.width,\n          x = _ref2.x,\n          y = _ref2.y;\n      var _this$props2 = this.props,\n          cellGroupRenderer = _this$props2.cellGroupRenderer,\n          cellRenderer = _this$props2.cellRenderer; // Store for later calls to getLastRenderedIndices()\n\n      this._lastRenderedCellIndices = this._sectionManager.getCellIndices({\n        height: height,\n        width: width,\n        x: x,\n        y: y\n      });\n      return cellGroupRenderer({\n        cellCache: this._cellCache,\n        cellRenderer: cellRenderer,\n        cellSizeAndPositionGetter: function cellSizeAndPositionGetter(_ref3) {\n          var index = _ref3.index;\n          return _this2._sectionManager.getCellMetadata({\n            index: index\n          });\n        },\n        indices: this._lastRenderedCellIndices,\n        isScrolling: isScrolling\n      });\n    }\n  }, {\n    key: \"_isScrollingChange\",\n    value: function _isScrollingChange(isScrolling) {\n      if (!isScrolling) {\n        this._cellCache = [];\n      }\n    }\n  }, {\n    key: \"_setCollectionViewRef\",\n    value: function _setCollectionViewRef(ref) {\n      this._collectionView = ref;\n    }\n  }]);\n\n  return Collection;\n}(React.PureComponent);\n\n_defineProperty(Collection, \"defaultProps\", {\n  'aria-label': 'grid',\n  cellGroupRenderer: defaultCellGroupRenderer\n});\n\nexport { Collection as default };\nCollection.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  'aria-label': PropTypes.string,\n\n  /**\n   * Number of cells in Collection.\n   */\n  cellCount: PropTypes.number.isRequired,\n\n  /**\n   * Responsible for rendering a group of cells given their indices.\n   * Should implement the following interface: ({\n   *   cellSizeAndPositionGetter:Function,\n   *   indices: Array<number>,\n   *   cellRenderer: Function\n   * }): Array<PropTypes.node>\n   */\n  cellGroupRenderer: PropTypes.func.isRequired,\n\n  /**\n   * Responsible for rendering a cell given an row and column index.\n   * Should implement the following interface: ({ index: number, key: string, style: object }): PropTypes.element\n   */\n  cellRenderer: PropTypes.func.isRequired,\n\n  /**\n   * Callback responsible for returning size and offset/position information for a given cell (index).\n   * ({ index: number }): { height: number, width: number, x: number, y: number }\n   */\n  cellSizeAndPositionGetter: PropTypes.func.isRequired,\n\n  /**\n   * Optionally override the size of the sections a Collection's cells are split into.\n   */\n  sectionSize: PropTypes.number\n} : {};\n\nfunction defaultCellGroupRenderer(_ref4) {\n  var cellCache = _ref4.cellCache,\n      cellRenderer = _ref4.cellRenderer,\n      cellSizeAndPositionGetter = _ref4.cellSizeAndPositionGetter,\n      indices = _ref4.indices,\n      isScrolling = _ref4.isScrolling;\n  return indices.map(function (index) {\n    var cellMetadata = cellSizeAndPositionGetter({\n      index: index\n    });\n    var cellRendererProps = {\n      index: index,\n      isScrolling: isScrolling,\n      key: index,\n      style: {\n        height: cellMetadata.height,\n        left: cellMetadata.x,\n        position: 'absolute',\n        top: cellMetadata.y,\n        width: cellMetadata.width\n      }\n    }; // Avoid re-creating cells while scrolling.\n    // This can lead to the same cell being created many times and can cause performance issues for \"heavy\" cells.\n    // If a scroll is in progress- cache and reuse cells.\n    // This cache will be thrown away once scrolling complets.\n\n    if (isScrolling) {\n      if (!(index in cellCache)) {\n        cellCache[index] = cellRenderer(cellRendererProps);\n      }\n\n      return cellCache[index];\n    } else {\n      return cellRenderer(cellRendererProps);\n    }\n  }).filter(function (renderedCell) {\n    return !!renderedCell;\n  });\n}\n\nimport { bpfrpt_proptype_ScrollPosition } from \"./types\";\nimport { bpfrpt_proptype_SizeInfo } from \"./types\";","map":{"version":3,"names":["_extends","_classCallCheck","_createClass","_possibleConstructorReturn","_getPrototypeOf","_assertThisInitialized","_inherits","_defineProperty","PropTypes","React","CollectionView","_calculateSizeAndPositionData","getUpdatedOffsetForIndex","Collection","_React$PureComponent","props","context","_this","call","_cellMetadata","_lastRenderedCellIndices","_cellCache","_isScrollingChange","bind","_setCollectionViewRef","key","value","forceUpdate","_collectionView","undefined","recomputeCellSizesAndPositions","render","createElement","cellLayoutManager","isScrollingChange","ref","calculateSizeAndPositionData","_this$props","cellCount","cellSizeAndPositionGetter","sectionSize","data","cellMetadata","_sectionManager","sectionManager","_height","height","_width","width","getLastRenderedIndices","getScrollPositionForCell","_ref","align","cellIndex","scrollLeft","scrollTop","cellOffset","x","cellSize","containerSize","currentOffset","targetIndex","y","getTotalSize","cellRenderers","_ref2","_this2","isScrolling","_this$props2","cellGroupRenderer","cellRenderer","getCellIndices","cellCache","_ref3","index","getCellMetadata","indices","PureComponent","defaultCellGroupRenderer","default","propTypes","process","env","NODE_ENV","string","number","isRequired","func","_ref4","map","cellRendererProps","style","left","position","top","filter","renderedCell","bpfrpt_proptype_ScrollPosition","bpfrpt_proptype_SizeInfo"],"sources":["/Users/stoneye/react_project/circle-app-react-hook/node_modules/react-virtualized/dist/es/Collection/Collection.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport PropTypes from 'prop-types';\nimport * as React from 'react';\nimport CollectionView from './CollectionView';\nimport _calculateSizeAndPositionData from './utils/calculateSizeAndPositionData';\nimport getUpdatedOffsetForIndex from '../utils/getUpdatedOffsetForIndex';\n\n/**\n * Renders scattered or non-linear data.\n * Unlike Grid, which renders checkerboard data, Collection can render arbitrarily positioned- even overlapping- data.\n */\nvar Collection =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(Collection, _React$PureComponent);\n\n  function Collection(props, context) {\n    var _this;\n\n    _classCallCheck(this, Collection);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Collection).call(this, props, context));\n    _this._cellMetadata = [];\n    _this._lastRenderedCellIndices = []; // Cell cache during scroll (for performance)\n\n    _this._cellCache = [];\n    _this._isScrollingChange = _this._isScrollingChange.bind(_assertThisInitialized(_this));\n    _this._setCollectionViewRef = _this._setCollectionViewRef.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(Collection, [{\n    key: \"forceUpdate\",\n    value: function forceUpdate() {\n      if (this._collectionView !== undefined) {\n        this._collectionView.forceUpdate();\n      }\n    }\n    /** See Collection#recomputeCellSizesAndPositions */\n\n  }, {\n    key: \"recomputeCellSizesAndPositions\",\n    value: function recomputeCellSizesAndPositions() {\n      this._cellCache = [];\n\n      this._collectionView.recomputeCellSizesAndPositions();\n    }\n    /** React lifecycle methods */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var props = _extends({}, this.props);\n\n      return React.createElement(CollectionView, _extends({\n        cellLayoutManager: this,\n        isScrollingChange: this._isScrollingChange,\n        ref: this._setCollectionViewRef\n      }, props));\n    }\n    /** CellLayoutManager interface */\n\n  }, {\n    key: \"calculateSizeAndPositionData\",\n    value: function calculateSizeAndPositionData() {\n      var _this$props = this.props,\n          cellCount = _this$props.cellCount,\n          cellSizeAndPositionGetter = _this$props.cellSizeAndPositionGetter,\n          sectionSize = _this$props.sectionSize;\n\n      var data = _calculateSizeAndPositionData({\n        cellCount: cellCount,\n        cellSizeAndPositionGetter: cellSizeAndPositionGetter,\n        sectionSize: sectionSize\n      });\n\n      this._cellMetadata = data.cellMetadata;\n      this._sectionManager = data.sectionManager;\n      this._height = data.height;\n      this._width = data.width;\n    }\n    /**\n     * Returns the most recently rendered set of cell indices.\n     */\n\n  }, {\n    key: \"getLastRenderedIndices\",\n    value: function getLastRenderedIndices() {\n      return this._lastRenderedCellIndices;\n    }\n    /**\n     * Calculates the minimum amount of change from the current scroll position to ensure the specified cell is (fully) visible.\n     */\n\n  }, {\n    key: \"getScrollPositionForCell\",\n    value: function getScrollPositionForCell(_ref) {\n      var align = _ref.align,\n          cellIndex = _ref.cellIndex,\n          height = _ref.height,\n          scrollLeft = _ref.scrollLeft,\n          scrollTop = _ref.scrollTop,\n          width = _ref.width;\n      var cellCount = this.props.cellCount;\n\n      if (cellIndex >= 0 && cellIndex < cellCount) {\n        var cellMetadata = this._cellMetadata[cellIndex];\n        scrollLeft = getUpdatedOffsetForIndex({\n          align: align,\n          cellOffset: cellMetadata.x,\n          cellSize: cellMetadata.width,\n          containerSize: width,\n          currentOffset: scrollLeft,\n          targetIndex: cellIndex\n        });\n        scrollTop = getUpdatedOffsetForIndex({\n          align: align,\n          cellOffset: cellMetadata.y,\n          cellSize: cellMetadata.height,\n          containerSize: height,\n          currentOffset: scrollTop,\n          targetIndex: cellIndex\n        });\n      }\n\n      return {\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop\n      };\n    }\n  }, {\n    key: \"getTotalSize\",\n    value: function getTotalSize() {\n      return {\n        height: this._height,\n        width: this._width\n      };\n    }\n  }, {\n    key: \"cellRenderers\",\n    value: function cellRenderers(_ref2) {\n      var _this2 = this;\n\n      var height = _ref2.height,\n          isScrolling = _ref2.isScrolling,\n          width = _ref2.width,\n          x = _ref2.x,\n          y = _ref2.y;\n      var _this$props2 = this.props,\n          cellGroupRenderer = _this$props2.cellGroupRenderer,\n          cellRenderer = _this$props2.cellRenderer; // Store for later calls to getLastRenderedIndices()\n\n      this._lastRenderedCellIndices = this._sectionManager.getCellIndices({\n        height: height,\n        width: width,\n        x: x,\n        y: y\n      });\n      return cellGroupRenderer({\n        cellCache: this._cellCache,\n        cellRenderer: cellRenderer,\n        cellSizeAndPositionGetter: function cellSizeAndPositionGetter(_ref3) {\n          var index = _ref3.index;\n          return _this2._sectionManager.getCellMetadata({\n            index: index\n          });\n        },\n        indices: this._lastRenderedCellIndices,\n        isScrolling: isScrolling\n      });\n    }\n  }, {\n    key: \"_isScrollingChange\",\n    value: function _isScrollingChange(isScrolling) {\n      if (!isScrolling) {\n        this._cellCache = [];\n      }\n    }\n  }, {\n    key: \"_setCollectionViewRef\",\n    value: function _setCollectionViewRef(ref) {\n      this._collectionView = ref;\n    }\n  }]);\n\n  return Collection;\n}(React.PureComponent);\n\n_defineProperty(Collection, \"defaultProps\", {\n  'aria-label': 'grid',\n  cellGroupRenderer: defaultCellGroupRenderer\n});\n\nexport { Collection as default };\nCollection.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  'aria-label': PropTypes.string,\n\n  /**\n   * Number of cells in Collection.\n   */\n  cellCount: PropTypes.number.isRequired,\n\n  /**\n   * Responsible for rendering a group of cells given their indices.\n   * Should implement the following interface: ({\n   *   cellSizeAndPositionGetter:Function,\n   *   indices: Array<number>,\n   *   cellRenderer: Function\n   * }): Array<PropTypes.node>\n   */\n  cellGroupRenderer: PropTypes.func.isRequired,\n\n  /**\n   * Responsible for rendering a cell given an row and column index.\n   * Should implement the following interface: ({ index: number, key: string, style: object }): PropTypes.element\n   */\n  cellRenderer: PropTypes.func.isRequired,\n\n  /**\n   * Callback responsible for returning size and offset/position information for a given cell (index).\n   * ({ index: number }): { height: number, width: number, x: number, y: number }\n   */\n  cellSizeAndPositionGetter: PropTypes.func.isRequired,\n\n  /**\n   * Optionally override the size of the sections a Collection's cells are split into.\n   */\n  sectionSize: PropTypes.number\n} : {};\n\nfunction defaultCellGroupRenderer(_ref4) {\n  var cellCache = _ref4.cellCache,\n      cellRenderer = _ref4.cellRenderer,\n      cellSizeAndPositionGetter = _ref4.cellSizeAndPositionGetter,\n      indices = _ref4.indices,\n      isScrolling = _ref4.isScrolling;\n  return indices.map(function (index) {\n    var cellMetadata = cellSizeAndPositionGetter({\n      index: index\n    });\n    var cellRendererProps = {\n      index: index,\n      isScrolling: isScrolling,\n      key: index,\n      style: {\n        height: cellMetadata.height,\n        left: cellMetadata.x,\n        position: 'absolute',\n        top: cellMetadata.y,\n        width: cellMetadata.width\n      }\n    }; // Avoid re-creating cells while scrolling.\n    // This can lead to the same cell being created many times and can cause performance issues for \"heavy\" cells.\n    // If a scroll is in progress- cache and reuse cells.\n    // This cache will be thrown away once scrolling complets.\n\n    if (isScrolling) {\n      if (!(index in cellCache)) {\n        cellCache[index] = cellRenderer(cellRendererProps);\n      }\n\n      return cellCache[index];\n    } else {\n      return cellRenderer(cellRendererProps);\n    }\n  }).filter(function (renderedCell) {\n    return !!renderedCell;\n  });\n}\n\nimport { bpfrpt_proptype_ScrollPosition } from \"./types\";\nimport { bpfrpt_proptype_SizeInfo } from \"./types\";"],"mappings":"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"},"metadata":{},"sourceType":"module"}