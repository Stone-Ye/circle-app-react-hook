{"ast":null,"code":"/**\n * Helper method that determines when to recalculate row or column metadata.\n */\nexport default function calculateSizeAndPositionDataAndUpdateScrollOffset(_ref) {\n  var cellCount = _ref.cellCount,\n      cellSize = _ref.cellSize,\n      computeMetadataCallback = _ref.computeMetadataCallback,\n      computeMetadataCallbackProps = _ref.computeMetadataCallbackProps,\n      nextCellsCount = _ref.nextCellsCount,\n      nextCellSize = _ref.nextCellSize,\n      nextScrollToIndex = _ref.nextScrollToIndex,\n      scrollToIndex = _ref.scrollToIndex,\n      updateScrollOffsetForScrollToIndex = _ref.updateScrollOffsetForScrollToIndex; // Don't compare cell sizes if they are functions because inline functions would cause infinite loops.\n  // In that event users should use the manual recompute methods to inform of changes.\n\n  if (cellCount !== nextCellsCount || (typeof cellSize === 'number' || typeof nextCellSize === 'number') && cellSize !== nextCellSize) {\n    computeMetadataCallback(computeMetadataCallbackProps); // Updated cell metadata may have hidden the previous scrolled-to item.\n    // In this case we should also update the scrollTop to ensure it stays visible.\n\n    if (scrollToIndex >= 0 && scrollToIndex === nextScrollToIndex) {\n      updateScrollOffsetForScrollToIndex();\n    }\n  }\n}","map":{"version":3,"names":["calculateSizeAndPositionDataAndUpdateScrollOffset","_ref","cellCount","cellSize","computeMetadataCallback","computeMetadataCallbackProps","nextCellsCount","nextCellSize","nextScrollToIndex","scrollToIndex","updateScrollOffsetForScrollToIndex"],"sources":["/Users/stoneye/react_project/circle-app-react-hook/node_modules/react-virtualized/dist/es/Grid/utils/calculateSizeAndPositionDataAndUpdateScrollOffset.js"],"sourcesContent":["/**\n * Helper method that determines when to recalculate row or column metadata.\n */\nexport default function calculateSizeAndPositionDataAndUpdateScrollOffset(_ref) {\n  var cellCount = _ref.cellCount,\n      cellSize = _ref.cellSize,\n      computeMetadataCallback = _ref.computeMetadataCallback,\n      computeMetadataCallbackProps = _ref.computeMetadataCallbackProps,\n      nextCellsCount = _ref.nextCellsCount,\n      nextCellSize = _ref.nextCellSize,\n      nextScrollToIndex = _ref.nextScrollToIndex,\n      scrollToIndex = _ref.scrollToIndex,\n      updateScrollOffsetForScrollToIndex = _ref.updateScrollOffsetForScrollToIndex;\n\n  // Don't compare cell sizes if they are functions because inline functions would cause infinite loops.\n  // In that event users should use the manual recompute methods to inform of changes.\n  if (cellCount !== nextCellsCount || (typeof cellSize === 'number' || typeof nextCellSize === 'number') && cellSize !== nextCellSize) {\n    computeMetadataCallback(computeMetadataCallbackProps); // Updated cell metadata may have hidden the previous scrolled-to item.\n    // In this case we should also update the scrollTop to ensure it stays visible.\n\n    if (scrollToIndex >= 0 && scrollToIndex === nextScrollToIndex) {\n      updateScrollOffsetForScrollToIndex();\n    }\n  }\n}"],"mappings":"AAAA;AACA;AACA;AACA,eAAe,SAASA,iDAAT,CAA2DC,IAA3D,EAAiE;EAC9E,IAAIC,SAAS,GAAGD,IAAI,CAACC,SAArB;EAAA,IACIC,QAAQ,GAAGF,IAAI,CAACE,QADpB;EAAA,IAEIC,uBAAuB,GAAGH,IAAI,CAACG,uBAFnC;EAAA,IAGIC,4BAA4B,GAAGJ,IAAI,CAACI,4BAHxC;EAAA,IAIIC,cAAc,GAAGL,IAAI,CAACK,cAJ1B;EAAA,IAKIC,YAAY,GAAGN,IAAI,CAACM,YALxB;EAAA,IAMIC,iBAAiB,GAAGP,IAAI,CAACO,iBAN7B;EAAA,IAOIC,aAAa,GAAGR,IAAI,CAACQ,aAPzB;EAAA,IAQIC,kCAAkC,GAAGT,IAAI,CAACS,kCAR9C,CAD8E,CAW9E;EACA;;EACA,IAAIR,SAAS,KAAKI,cAAd,IAAgC,CAAC,OAAOH,QAAP,KAAoB,QAApB,IAAgC,OAAOI,YAAP,KAAwB,QAAzD,KAAsEJ,QAAQ,KAAKI,YAAvH,EAAqI;IACnIH,uBAAuB,CAACC,4BAAD,CAAvB,CADmI,CAC5E;IACvD;;IAEA,IAAII,aAAa,IAAI,CAAjB,IAAsBA,aAAa,KAAKD,iBAA5C,EAA+D;MAC7DE,kCAAkC;IACnC;EACF;AACF"},"metadata":{},"sourceType":"module"}